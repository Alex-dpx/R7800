The system is: Linux - 3.2.0-99-virtual - x86_64
Compiling the C compiler identification source file "CMakeCCompilerId.c" succeeded.
Compiler: /usr/bin/clang 
Build flags: 
Id flags: 

The output was:
0


Compilation of the C compiler identification source "CMakeCCompilerId.c" produced "a.out"

The C compiler identification is Clang, found in "/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CompilerIdC/a.out"

Compiling the CXX compiler identification source file "CMakeCXXCompilerId.cpp" succeeded.
Compiler: /usr/bin/clang++ 
Build flags: 
Id flags: 

The output was:
0


Compilation of the CXX compiler identification source "CMakeCXXCompilerId.cpp" produced "a.out"

The CXX compiler identification is Clang, found in "/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CompilerIdCXX/a.out"

Determining if the C compiler works passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3363235472/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3363235472.dir/build.make CMakeFiles/cmTryCompileExec3363235472.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3363235472.dir/testCCompiler.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3363235472.dir/testCCompiler.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/testCCompiler.c
Linking C executable cmTryCompileExec3363235472
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3363235472.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3363235472.dir/testCCompiler.c.o  -o cmTryCompileExec3363235472 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Detecting C compiler ABI info compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec501360679/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec501360679.dir/build.make CMakeFiles/cmTryCompileExec501360679.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CMakeCCompilerABI.c
Linking C executable cmTryCompileExec501360679
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec501360679.dir/link.txt --verbose=1
/usr/bin/clang       -v CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec501360679 -rdynamic  
Ubuntu clang version 3.4-1ubuntu3~precise2 (tags/RELEASE_34/final) (based on LLVM 3.4)
Target: x86_64-pc-linux-gnu
Thread model: posix
Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6
Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6.3
Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6
Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6.3
Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6
Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6.3
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6.3
Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6
 "/usr/bin/ld" -export-dynamic -z relro --hash-style=gnu --build-id --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec501360679 /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6 -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../.. -L/lib -L/usr/lib CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Parsed C implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec501360679/fast"]
  ignore line: [make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec501360679.dir/build.make CMakeFiles/cmTryCompileExec501360679.dir/build]
  ignore line: [make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building C object CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o]
  ignore line: [/usr/bin/clang    -o CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CMakeCCompilerABI.c]
  ignore line: [Linking C executable cmTryCompileExec501360679]
  ignore line: [/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec501360679.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/clang       -v CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o  -o cmTryCompileExec501360679 -rdynamic  ]
  ignore line: [Ubuntu clang version 3.4-1ubuntu3~precise2 (tags/RELEASE_34/final) (based on LLVM 3.4)]
  ignore line: [Target: x86_64-pc-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6.3]
  ignore line: [Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
  link line: [ "/usr/bin/ld" -export-dynamic -z relro --hash-style=gnu --build-id --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec501360679 /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6 -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../.. -L/lib -L/usr/lib CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/bin/ld] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-zrelro] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec501360679] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o] ==> ignore
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib64] ==> dir [/lib/../lib64]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..]
    arg [-L/lib] ==> dir [/lib]
    arg [-L/usr/lib] ==> dir [/usr/lib]
    arg [CMakeFiles/cmTryCompileExec501360679.dir/CMakeCCompilerABI.c.o] ==> ignore
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [-lc] ==> lib [c]
    arg [-lgcc] ==> lib [gcc]
    arg [--as-needed] ==> ignore
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [--no-as-needed] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.6]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse dir [/lib/../lib64] ==> [/lib64]
  collapse dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..] ==> [/usr/lib]
  collapse dir [/lib] ==> [/lib]
  collapse dir [/usr/lib] ==> [/usr/lib]
  implicit libs: [c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.6;/usr/lib/x86_64-linux-gnu;/lib/x86_64-linux-gnu;/lib64;/usr/lib;/lib]


Determining if the CXX compiler works passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4203556168/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4203556168.dir/build.make CMakeFiles/cmTryCompileExec4203556168.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4203556168.dir/testCXXCompiler.cxx.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec4203556168.dir/testCXXCompiler.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
Linking CXX executable cmTryCompileExec4203556168
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4203556168.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec4203556168.dir/testCXXCompiler.cxx.o  -o cmTryCompileExec4203556168 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Detecting CXX compiler ABI info compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1318741035/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1318741035.dir/build.make CMakeFiles/cmTryCompileExec1318741035.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CMakeCXXCompilerABI.cpp
Linking CXX executable cmTryCompileExec1318741035
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1318741035.dir/link.txt --verbose=1
/usr/bin/clang++        -v CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec1318741035 -rdynamic  
Ubuntu clang version 3.4-1ubuntu3~precise2 (tags/RELEASE_34/final) (based on LLVM 3.4)
Target: x86_64-pc-linux-gnu
Thread model: posix
Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6
Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6.3
Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6
Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6.3
Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6
Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6.3
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6
Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6.3
Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6
 "/usr/bin/ld" -export-dynamic -z relro --hash-style=gnu --build-id --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec1318741035 /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6 -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../.. -L/lib -L/usr/lib CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Parsed CXX implicit link information from above output:
  link line regex: [^( *|.*[/\])(ld|ld|collect2)[^/\]*( |$)]
  ignore line: [Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp]
  ignore line: []
  ignore line: [Run Build Command:/usr/bin/make "cmTryCompileExec1318741035/fast"]
  ignore line: [make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [make -f CMakeFiles/cmTryCompileExec1318741035.dir/build.make CMakeFiles/cmTryCompileExec1318741035.dir/build]
  ignore line: [make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp']
  ignore line: [/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1]
  ignore line: [Building CXX object CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o]
  ignore line: [/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CMakeCXXCompilerABI.cpp]
  ignore line: [Linking CXX executable cmTryCompileExec1318741035]
  ignore line: [/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1318741035.dir/link.txt --verbose=1]
  ignore line: [/usr/bin/clang++        -v CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o  -o cmTryCompileExec1318741035 -rdynamic  ]
  ignore line: [Ubuntu clang version 3.4-1ubuntu3~precise2 (tags/RELEASE_34/final) (based on LLVM 3.4)]
  ignore line: [Target: x86_64-pc-linux-gnu]
  ignore line: [Thread model: posix]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/i686-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/i686-linux-gnu/4.6.3]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6]
  ignore line: [Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.6.3]
  ignore line: [Selected GCC installation: /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
  link line: [ "/usr/bin/ld" -export-dynamic -z relro --hash-style=gnu --build-id --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o cmTryCompileExec1318741035 /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6 -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../.. -L/lib -L/usr/lib CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o /usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o]
    arg [/usr/bin/ld] ==> ignore
    arg [-export-dynamic] ==> ignore
    arg [-zrelro] ==> ignore
    arg [--hash-style=gnu] ==> ignore
    arg [--build-id] ==> ignore
    arg [--eh-frame-hdr] ==> ignore
    arg [-m] ==> ignore
    arg [elf_x86_64] ==> ignore
    arg [-dynamic-linker] ==> ignore
    arg [/lib64/ld-linux-x86-64.so.2] ==> ignore
    arg [-o] ==> ignore
    arg [cmTryCompileExec1318741035] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crt1.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crti.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtbegin.o] ==> ignore
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6]
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu]
    arg [-L/lib/x86_64-linux-gnu] ==> dir [/lib/x86_64-linux-gnu]
    arg [-L/lib/../lib64] ==> dir [/lib/../lib64]
    arg [-L/usr/lib/x86_64-linux-gnu] ==> dir [/usr/lib/x86_64-linux-gnu]
    arg [-L/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..] ==> dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..]
    arg [-L/lib] ==> dir [/lib]
    arg [-L/usr/lib] ==> dir [/usr/lib]
    arg [CMakeFiles/cmTryCompileExec1318741035.dir/CMakeCXXCompilerABI.cpp.o] ==> ignore
    arg [-lstdc++] ==> lib [stdc++]
    arg [-lm] ==> lib [m]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [-lc] ==> lib [c]
    arg [-lgcc_s] ==> lib [gcc_s]
    arg [-lgcc] ==> lib [gcc]
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/crtend.o] ==> ignore
    arg [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu/crtn.o] ==> ignore
  remove lib [gcc_s]
  remove lib [gcc]
  remove lib [gcc_s]
  remove lib [gcc]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6] ==> [/usr/lib/gcc/x86_64-linux-gnu/4.6]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../../x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse dir [/lib/x86_64-linux-gnu] ==> [/lib/x86_64-linux-gnu]
  collapse dir [/lib/../lib64] ==> [/lib64]
  collapse dir [/usr/lib/x86_64-linux-gnu] ==> [/usr/lib/x86_64-linux-gnu]
  collapse dir [/usr/bin/../lib/gcc/x86_64-linux-gnu/4.6/../../..] ==> [/usr/lib]
  collapse dir [/lib] ==> [/lib]
  collapse dir [/usr/lib] ==> [/usr/lib]
  implicit libs: [stdc++;m;c]
  implicit dirs: [/usr/lib/gcc/x86_64-linux-gnu/4.6;/usr/lib/x86_64-linux-gnu;/lib/x86_64-linux-gnu;/lib64;/usr/lib;/lib]


Determining if the include file iostream exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec30104295/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec30104295.dir/build.make CMakeFiles/cmTryCompileExec30104295.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec30104295.dir/CheckIncludeFile.cxx.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec30104295.dir/CheckIncludeFile.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.cxx
Linking CXX executable cmTryCompileExec30104295
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec30104295.dir/link.txt --verbose=1
/usr/bin/clang++           CMakeFiles/cmTryCompileExec30104295.dir/CheckIncludeFile.cxx.o  -o cmTryCompileExec30104295 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has std namespace passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2064093752/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2064093752.dir/build.make CMakeFiles/cmTryCompileExec2064093752.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2064093752.dir/TestForSTDNamespace.cxx.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec2064093752.dir/TestForSTDNamespace.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/TestForSTDNamespace.cxx
Linking CXX executable cmTryCompileExec2064093752
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2064093752.dir/link.txt --verbose=1
/usr/bin/clang++           CMakeFiles/cmTryCompileExec2064093752.dir/TestForSTDNamespace.cxx.o  -o cmTryCompileExec2064093752 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler understands ansi for scopes passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3197319143/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3197319143.dir/build.make CMakeFiles/cmTryCompileExec3197319143.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3197319143.dir/TestForAnsiForScope.cxx.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec3197319143.dir/TestForAnsiForScope.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/TestForAnsiForScope.cxx
Linking CXX executable cmTryCompileExec3197319143
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3197319143.dir/link.txt --verbose=1
/usr/bin/clang++           CMakeFiles/cmTryCompileExec3197319143.dir/TestForAnsiForScope.cxx.o  -o cmTryCompileExec3197319143 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the CXX compiler has sstream passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec905751657/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec905751657.dir/build.make CMakeFiles/cmTryCompileExec905751657.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec905751657.dir/TestForSSTREAM.cxx.o
/usr/bin/clang++     -o CMakeFiles/cmTryCompileExec905751657.dir/TestForSSTREAM.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/TestForSSTREAM.cxx
Linking CXX executable cmTryCompileExec905751657
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec905751657.dir/link.txt --verbose=1
/usr/bin/clang++           CMakeFiles/cmTryCompileExec905751657.dir/TestForSSTREAM.cxx.o  -o cmTryCompileExec905751657 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the unsetenv exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec454329373/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec454329373.dir/build.make CMakeFiles/cmTryCompileExec454329373.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec454329373.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec454329373.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec454329373
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec454329373.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec454329373.dir/CheckSymbolExists.c.o  -o cmTryCompileExec454329373 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdlib.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef unsetenv
  return ((int*)(&unsetenv))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Checking whether header cstdio is available compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec721903410/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec721903410.dir/build.make CMakeFiles/cmTryCompileExec721903410.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec721903410.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_CSTDIO  -o CMakeFiles/cmTryCompileExec721903410.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec721903410
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec721903410.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec721903410.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec721903410 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for Large File Support compiled and ran with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2449251179/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2449251179.dir/build.make CMakeFiles/cmTryCompileExec2449251179.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2449251179.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_LFS_WORKS -DKWSYS_CXX_HAS_CSTDIO=1  -o CMakeFiles/cmTryCompileExec2449251179.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2449251179
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2449251179.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2449251179.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2449251179 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether STL classes are in std namespace compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1912234391/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1912234391.dir/build.make CMakeFiles/cmTryCompileExec1912234391.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1912234391.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_HAVE_STD  -o CMakeFiles/cmTryCompileExec1912234391.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1912234391
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1912234391.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1912234391.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1912234391 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI stream headers are available compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1190706997/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1190706997.dir/build.make CMakeFiles/cmTryCompileExec1190706997.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1190706997.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_USE_ANSI  -o CMakeFiles/cmTryCompileExec1190706997.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1190706997
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1190706997.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1190706997.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1190706997 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI streams are in std namespace compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4111685384/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4111685384.dir/build.make CMakeFiles/cmTryCompileExec4111685384.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4111685384.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_HAVE_STD  -o CMakeFiles/cmTryCompileExec4111685384.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4111685384
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4111685384.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec4111685384.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4111685384 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ANSI string stream is available compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2920529158/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2920529158.dir/build.make CMakeFiles/cmTryCompileExec2920529158.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2920529158.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_USE_SSTREAM  -o CMakeFiles/cmTryCompileExec2920529158.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2920529158
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2920529158.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2920529158.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2920529158 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether header cstddef is available compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2749481234/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2749481234.dir/build.make CMakeFiles/cmTryCompileExec2749481234.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2749481234.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_CSTDDEF  -o CMakeFiles/cmTryCompileExec2749481234.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2749481234
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2749481234.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2749481234.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2749481234 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl string has operator!= for char* compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4082571629/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4082571629.dir/build.make CMakeFiles/cmTryCompileExec4082571629.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec4082571629.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_STRING_HAVE_NEQ_CHAR -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec4082571629.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec4082571629
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4082571629.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec4082571629.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec4082571629 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has iterator_traits compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1507742608/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1507742608.dir/build.make CMakeFiles/cmTryCompileExec1507742608.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1507742608.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_HAS_ITERATOR_TRAITS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec1507742608.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1507742608
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1507742608.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1507742608.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1507742608 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl has standard template allocator compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec926867632/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec926867632.dir/build.make CMakeFiles/cmTryCompileExec926867632.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec926867632.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_TEMPLATE -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec926867632.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec926867632
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec926867632.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec926867632.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec926867632 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for rebind member of stl allocator compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1127447906/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1127447906.dir/build.make CMakeFiles/cmTryCompileExec1127447906.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1127447906.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_REBIND -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec1127447906.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1127447906
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1127447906.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1127447906.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1127447906 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether stl containers support allocator objects. compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec791829790/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec791829790.dir/build.make CMakeFiles/cmTryCompileExec791829790.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec791829790.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STL_HAS_ALLOCATOR_OBJECTS -DKWSYS_STL_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec791829790.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec791829790
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec791829790.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec791829790.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec791829790 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether ios has binary openmode compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2774666768/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2774666768.dir/build.make CMakeFiles/cmTryCompileExec2774666768.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2774666768.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_HAVE_BINARY -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec2774666768.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2774666768
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2774666768.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2774666768.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2774666768 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for member template support compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2651964385/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2651964385.dir/build.make CMakeFiles/cmTryCompileExec2651964385.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2651964385.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_MEMBER_TEMPLATES  -o CMakeFiles/cmTryCompileExec2651964385.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2651964385
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2651964385.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2651964385.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2651964385 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for standard template specialization syntax compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2493639028/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2493639028.dir/build.make CMakeFiles/cmTryCompileExec2493639028.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2493639028.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_FULL_SPECIALIZATION  -o CMakeFiles/cmTryCompileExec2493639028.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2493639028
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2493639028.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2493639028.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2493639028 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether argument dependent lookup is supported compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec677235853/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec677235853.dir/build.make CMakeFiles/cmTryCompileExec677235853.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec677235853.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_ARGUMENT_DEPENDENT_LOOKUP  -o CMakeFiles/cmTryCompileExec677235853.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec677235853
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec677235853.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec677235853.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec677235853 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether struct stat has st_mtim member compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1553572594/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1553572594.dir/build.make CMakeFiles/cmTryCompileExec1553572594.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1553572594.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_STAT_HAS_ST_MTIM  -o CMakeFiles/cmTryCompileExec1553572594.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1553572594
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1553572594.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1553572594.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1553572594 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C++ compiler has 'long long' compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1778147766/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1778147766.dir/build.make CMakeFiles/cmTryCompileExec1778147766.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1778147766.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_LONG_LONG  -o CMakeFiles/cmTryCompileExec1778147766.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1778147766
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1778147766.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1778147766.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1778147766 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking for C type size macros compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec249646991/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec249646991.dir/build.make CMakeFiles/cmTryCompileExec249646991.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec249646991.dir/kwsysPlatformTestsC.c.o
/usr/bin/clang  -DTEST_KWSYS_C_TYPE_MACROS  -o CMakeFiles/cmTryCompileExec249646991.dir/kwsysPlatformTestsC.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec249646991
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec249646991.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec249646991.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec249646991 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the include file sys/types.h exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec443024015/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec443024015.dir/build.make CMakeFiles/cmTryCompileExec443024015.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec443024015.dir/CheckIncludeFile.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec443024015.dir/CheckIncludeFile.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec443024015
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec443024015.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec443024015.dir/CheckIncludeFile.c.o  -o cmTryCompileExec443024015 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file stdint.h exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3588817921/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3588817921.dir/build.make CMakeFiles/cmTryCompileExec3588817921.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3588817921.dir/CheckIncludeFile.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3588817921.dir/CheckIncludeFile.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3588817921
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3588817921.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3588817921.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3588817921 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file stddef.h exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3586787262/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3586787262.dir/build.make CMakeFiles/cmTryCompileExec3586787262.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3586787262.dir/CheckIncludeFile.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3586787262.dir/CheckIncludeFile.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3586787262
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3586787262.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3586787262.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3586787262 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of char passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3981125913/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3981125913.dir/build.make CMakeFiles/cmTryCompileExec3981125913.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3981125913.dir/KWSYS_SIZEOF_CHAR.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3981125913.dir/KWSYS_SIZEOF_CHAR.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/KWSYS_SIZEOF_CHAR.c
Linking C executable cmTryCompileExec3981125913
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3981125913.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3981125913.dir/KWSYS_SIZEOF_CHAR.c.o  -o cmTryCompileExec3981125913 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Checking whether char is signed compiled and ran with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2577914905/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2577914905.dir/build.make CMakeFiles/cmTryCompileExec2577914905.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2577914905.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CHAR_IS_SIGNED  -o CMakeFiles/cmTryCompileExec2577914905.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2577914905
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2577914905.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2577914905.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2577914905 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if istream supports long long compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3037438715/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3037438715.dir/build.make CMakeFiles/cmTryCompileExec3037438715.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec3037438715.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_HAS_ISTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec3037438715.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec3037438715
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3037438715.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec3037438715.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec3037438715 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking if ostream supports long long compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec772100812/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec772100812.dir/build.make CMakeFiles/cmTryCompileExec772100812.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec772100812.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_IOS_HAS_OSTREAM_LONG_LONG -DKWSYS_IOS_USE_ANSI=1 -DKWSYS_IOS_HAVE_STD=1  -o CMakeFiles/cmTryCompileExec772100812.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec772100812
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec772100812.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec772100812.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec772100812 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ptrdiff_t in stddef.h compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1368085257/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1368085257.dir/build.make CMakeFiles/cmTryCompileExec1368085257.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1368085257.dir/kwsysPlatformTestsC.c.o
/usr/bin/clang  -DTEST_KWSYS_C_HAS_PTRDIFF_T  -o CMakeFiles/cmTryCompileExec1368085257.dir/kwsysPlatformTestsC.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec1368085257
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1368085257.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec1368085257.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec1368085257 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether C compiler has ssize_t in unistd.h compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3361130703/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3361130703.dir/build.make CMakeFiles/cmTryCompileExec3361130703.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3361130703.dir/kwsysPlatformTestsC.c.o
/usr/bin/clang  -DTEST_KWSYS_C_HAS_SSIZE_T  -o CMakeFiles/cmTryCompileExec3361130703.dir/kwsysPlatformTestsC.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsC.c
Linking C executable cmTryCompileExec3361130703
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3361130703.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3361130703.dir/kwsysPlatformTestsC.c.o  -o cmTryCompileExec3361130703 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has setenv compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1573589937/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1573589937.dir/build.make CMakeFiles/cmTryCompileExec1573589937.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec1573589937.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_SETENV  -o CMakeFiles/cmTryCompileExec1573589937.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec1573589937
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1573589937.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec1573589937.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec1573589937 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Checking whether CXX compiler has unsetenv compiled with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2444000580/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2444000580.dir/build.make CMakeFiles/cmTryCompileExec2444000580.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp/CMakeFiles 1
Building CXX object CMakeFiles/cmTryCompileExec2444000580.dir/kwsysPlatformTestsCXX.cxx.o
/usr/bin/clang++   -DTEST_KWSYS_CXX_HAS_UNSETENV  -o CMakeFiles/cmTryCompileExec2444000580.dir/kwsysPlatformTestsCXX.cxx.o -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/kwsysPlatformTestsCXX.cxx
Linking CXX executable cmTryCompileExec2444000580
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2444000580.dir/link.txt --verbose=1
/usr/bin/clang++          CMakeFiles/cmTryCompileExec2444000580.dir/kwsysPlatformTestsCXX.cxx.o  -o cmTryCompileExec2444000580 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Source/kwsys/CMakeFiles/CMakeTmp'


Determining if the function gethostbyname exists in the c passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1987184043/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1987184043.dir/build.make CMakeFiles/cmTryCompileExec1987184043.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1987184043.dir/CheckFunctionExists.c.o
/usr/bin/clang   -DCHECK_FUNCTION_EXISTS=gethostbyname   -o CMakeFiles/cmTryCompileExec1987184043.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1987184043
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1987184043.dir/link.txt --verbose=1
/usr/bin/clang      -DCHECK_FUNCTION_EXISTS=gethostbyname    CMakeFiles/cmTryCompileExec1987184043.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1987184043 -rdynamic -lc 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function dlopen exists in the dl passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2670937198/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2670937198.dir/build.make CMakeFiles/cmTryCompileExec2670937198.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2670937198.dir/CheckFunctionExists.c.o
/usr/bin/clang   -DCHECK_FUNCTION_EXISTS=dlopen   -o CMakeFiles/cmTryCompileExec2670937198.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2670937198
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2670937198.dir/link.txt --verbose=1
/usr/bin/clang      -DCHECK_FUNCTION_EXISTS=dlopen    CMakeFiles/cmTryCompileExec2670937198.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2670937198 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file features.h exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3603181337/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3603181337.dir/build.make CMakeFiles/cmTryCompileExec3603181337.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3603181337.dir/CheckIncludeFile.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3603181337.dir/CheckIncludeFile.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3603181337
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3603181337.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3603181337.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3603181337 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files ;stdio.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec497267801/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec497267801.dir/build.make CMakeFiles/cmTryCompileExec497267801.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec497267801.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec497267801.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec497267801
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec497267801.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec497267801.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec497267801 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec426272839/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec426272839.dir/build.make CMakeFiles/cmTryCompileExec426272839.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec426272839.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec426272839.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec426272839
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec426272839.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec426272839.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec426272839 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec54870630/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec54870630.dir/build.make CMakeFiles/cmTryCompileExec54870630.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec54870630.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec54870630.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec54870630
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec54870630.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec54870630.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec54870630 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1834479134/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1834479134.dir/build.make CMakeFiles/cmTryCompileExec1834479134.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1834479134.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1834479134.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1834479134
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1834479134.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1834479134.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1834479134 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec955448944/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec955448944.dir/build.make CMakeFiles/cmTryCompileExec955448944.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec955448944.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec955448944.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec955448944
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec955448944.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec955448944.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec955448944 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec416410025/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec416410025.dir/build.make CMakeFiles/cmTryCompileExec416410025.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec416410025.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec416410025.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec416410025
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec416410025.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec416410025.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec416410025 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1284901400/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1284901400.dir/build.make CMakeFiles/cmTryCompileExec1284901400.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1284901400.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1284901400.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1284901400
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1284901400.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1284901400.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1284901400 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec985665590/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec985665590.dir/build.make CMakeFiles/cmTryCompileExec985665590.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec985665590.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec985665590.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec985665590
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec985665590.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec985665590.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec985665590 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1108354448/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1108354448.dir/build.make CMakeFiles/cmTryCompileExec1108354448.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1108354448.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1108354448.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1108354448
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1108354448.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1108354448.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1108354448 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1601211691/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1601211691.dir/build.make CMakeFiles/cmTryCompileExec1601211691.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1601211691.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1601211691.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1601211691
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1601211691.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1601211691.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1601211691 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2354899680/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2354899680.dir/build.make CMakeFiles/cmTryCompileExec2354899680.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2354899680.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2354899680.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2354899680
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2354899680.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2354899680.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2354899680 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2050900224/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2050900224.dir/build.make CMakeFiles/cmTryCompileExec2050900224.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2050900224.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2050900224.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2050900224
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2050900224.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2050900224.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2050900224 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1228505521/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1228505521.dir/build.make CMakeFiles/cmTryCompileExec1228505521.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1228505521.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1228505521.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1228505521
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1228505521.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1228505521.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1228505521 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3134712443/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3134712443.dir/build.make CMakeFiles/cmTryCompileExec3134712443.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3134712443.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3134712443.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3134712443
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3134712443.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3134712443.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3134712443 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec177364510/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec177364510.dir/build.make CMakeFiles/cmTryCompileExec177364510.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec177364510.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec177364510.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec177364510
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec177364510.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec177364510.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec177364510 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1914299196/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1914299196.dir/build.make CMakeFiles/cmTryCompileExec1914299196.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1914299196.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1914299196.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1914299196
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1914299196.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1914299196.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1914299196 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3353335675/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3353335675.dir/build.make CMakeFiles/cmTryCompileExec3353335675.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3353335675.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3353335675.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3353335675
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3353335675.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3353335675.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3353335675 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2984625444/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2984625444.dir/build.make CMakeFiles/cmTryCompileExec2984625444.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2984625444.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2984625444.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2984625444
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2984625444.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2984625444.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2984625444 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1631347155/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1631347155.dir/build.make CMakeFiles/cmTryCompileExec1631347155.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1631347155.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1631347155.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1631347155
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1631347155.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1631347155.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1631347155 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1470197456/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1470197456.dir/build.make CMakeFiles/cmTryCompileExec1470197456.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1470197456.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1470197456.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1470197456
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1470197456.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1470197456.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1470197456 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2807600388/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2807600388.dir/build.make CMakeFiles/cmTryCompileExec2807600388.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2807600388.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2807600388.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2807600388
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2807600388.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2807600388.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2807600388 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec716059371/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec716059371.dir/build.make CMakeFiles/cmTryCompileExec716059371.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec716059371.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec716059371.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec716059371
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec716059371.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec716059371.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec716059371 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec143292725/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec143292725.dir/build.make CMakeFiles/cmTryCompileExec143292725.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec143292725.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec143292725.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec143292725
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec143292725.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec143292725.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec143292725 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2161851081/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2161851081.dir/build.make CMakeFiles/cmTryCompileExec2161851081.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2161851081.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2161851081.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2161851081
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2161851081.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2161851081.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2161851081 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1155466182/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1155466182.dir/build.make CMakeFiles/cmTryCompileExec1155466182.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1155466182.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1155466182.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1155466182
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1155466182.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1155466182.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1155466182 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1356003380/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1356003380.dir/build.make CMakeFiles/cmTryCompileExec1356003380.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1356003380.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1356003380.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1356003380
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1356003380.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1356003380.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1356003380 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec161649964/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec161649964.dir/build.make CMakeFiles/cmTryCompileExec161649964.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec161649964.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec161649964.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec161649964
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec161649964.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec161649964.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec161649964 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2097270887/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2097270887.dir/build.make CMakeFiles/cmTryCompileExec2097270887.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2097270887.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2097270887.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2097270887
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2097270887.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2097270887.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2097270887 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3097435488/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3097435488.dir/build.make CMakeFiles/cmTryCompileExec3097435488.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3097435488.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3097435488.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3097435488
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3097435488.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3097435488.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3097435488 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2417759876/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2417759876.dir/build.make CMakeFiles/cmTryCompileExec2417759876.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2417759876.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2417759876.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2417759876
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2417759876.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2417759876.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2417759876 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2571551442/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2571551442.dir/build.make CMakeFiles/cmTryCompileExec2571551442.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2571551442.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2571551442.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2571551442
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2571551442.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2571551442.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2571551442 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3450905420/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3450905420.dir/build.make CMakeFiles/cmTryCompileExec3450905420.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3450905420.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3450905420.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3450905420
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3450905420.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3450905420.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3450905420 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3515614742/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3515614742.dir/build.make CMakeFiles/cmTryCompileExec3515614742.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3515614742.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3515614742.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3515614742
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3515614742.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3515614742.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3515614742 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3237627738/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3237627738.dir/build.make CMakeFiles/cmTryCompileExec3237627738.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3237627738.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3237627738.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3237627738
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3237627738.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3237627738.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3237627738 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2585240507/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2585240507.dir/build.make CMakeFiles/cmTryCompileExec2585240507.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2585240507.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2585240507.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2585240507
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2585240507.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2585240507.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2585240507 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1208447246/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1208447246.dir/build.make CMakeFiles/cmTryCompileExec1208447246.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1208447246.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1208447246.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1208447246
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1208447246.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1208447246.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1208447246 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3375067256/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3375067256.dir/build.make CMakeFiles/cmTryCompileExec3375067256.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3375067256.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3375067256.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3375067256
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3375067256.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3375067256.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3375067256 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3293374789/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3293374789.dir/build.make CMakeFiles/cmTryCompileExec3293374789.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3293374789.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3293374789.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3293374789
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3293374789.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3293374789.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3293374789 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec444124491/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec444124491.dir/build.make CMakeFiles/cmTryCompileExec444124491.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec444124491.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec444124491.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec444124491
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec444124491.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec444124491.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec444124491 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files stdio.h;stddef.h;sys/types.h;inttypes.h;alloca.h;arpa/inet.h;dlfcn.h;fcntl.h;malloc.h;memory.h;netdb.h;sys/poll.h;assert.h;limits.h;sys/socket.h;netinet/in.h;net/if.h;netinet/if_ether.h;netinet/tcp.h;sys/select.h;utime.h;netinet/in.h;pwd.h;sgtty.h;stdint.h;stdlib.h;string.h;strings.h;sys/param.h;sys/stat.h;sys/time.h;sys/resource.h;termios.h;termio.h;time.h;unistd.h;locale.h;setjmp.h;signal.h;sys/ioctl.h;sys/utsname.h;arpa/tftp.h;errno.h;libgen.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2448704378/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2448704378.dir/build.make CMakeFiles/cmTryCompileExec2448704378.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2448704378.dir/CheckIncludeFiles.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2448704378.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2448704378
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2448704378.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2448704378.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2448704378 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1638166668/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1638166668.dir/build.make CMakeFiles/cmTryCompileExec1638166668.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1638166668.dir/SIZEOF_SIZE_T.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1638166668.dir/SIZEOF_SIZE_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SIZE_T.c
Linking C executable cmTryCompileExec1638166668
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1638166668.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1638166668.dir/SIZEOF_SIZE_T.c.o  -o cmTryCompileExec1638166668 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2653533432/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2653533432.dir/build.make CMakeFiles/cmTryCompileExec2653533432.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2653533432.dir/SIZEOF_SSIZE_T.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2653533432.dir/SIZEOF_SSIZE_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SSIZE_T.c
Linking C executable cmTryCompileExec2653533432
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2653533432.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2653533432.dir/SIZEOF_SSIZE_T.c.o  -o cmTryCompileExec2653533432 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3063983589/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3063983589.dir/build.make CMakeFiles/cmTryCompileExec3063983589.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3063983589.dir/SIZEOF_LONG_LONG.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3063983589.dir/SIZEOF_LONG_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_LONG_LONG.c
Linking C executable cmTryCompileExec3063983589
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3063983589.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3063983589.dir/SIZEOF_LONG_LONG.c.o  -o cmTryCompileExec3063983589 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1723759093/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1723759093.dir/build.make CMakeFiles/cmTryCompileExec1723759093.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1723759093.dir/SIZEOF_LONG.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1723759093.dir/SIZEOF_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_LONG.c
Linking C executable cmTryCompileExec1723759093
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1723759093.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1723759093.dir/SIZEOF_LONG.c.o  -o cmTryCompileExec1723759093 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of time_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3619401864/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3619401864.dir/build.make CMakeFiles/cmTryCompileExec3619401864.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3619401864.dir/SIZEOF_TIME_T.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3619401864.dir/SIZEOF_TIME_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_TIME_T.c
Linking C executable cmTryCompileExec3619401864
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3619401864.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3619401864.dir/SIZEOF_TIME_T.c.o  -o cmTryCompileExec3619401864 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the basename exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1243200531/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1243200531.dir/build.make CMakeFiles/cmTryCompileExec1243200531.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1243200531.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1243200531.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1243200531
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1243200531.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1243200531.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1243200531 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef basename
  return ((int*)(&basename))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the socket exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2470915312/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2470915312.dir/build.make CMakeFiles/cmTryCompileExec2470915312.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2470915312.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2470915312.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2470915312
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2470915312.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2470915312.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2470915312 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef socket
  return ((int*)(&socket))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the poll exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3480971845/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3480971845.dir/build.make CMakeFiles/cmTryCompileExec3480971845.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3480971845.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3480971845.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3480971845
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3480971845.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3480971845.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3480971845 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef poll
  return ((int*)(&poll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the select exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1000039889/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1000039889.dir/build.make CMakeFiles/cmTryCompileExec1000039889.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1000039889.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1000039889.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1000039889
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1000039889.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1000039889.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1000039889 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef select
  return ((int*)(&select))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strdup exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec528693501/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec528693501.dir/build.make CMakeFiles/cmTryCompileExec528693501.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec528693501.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec528693501.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec528693501
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec528693501.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec528693501.dir/CheckSymbolExists.c.o  -o cmTryCompileExec528693501 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strdup
  return ((int*)(&strdup))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strstr exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec736236660/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec736236660.dir/build.make CMakeFiles/cmTryCompileExec736236660.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec736236660.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec736236660.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec736236660
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec736236660.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec736236660.dir/CheckSymbolExists.c.o  -o cmTryCompileExec736236660 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strstr
  return ((int*)(&strstr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtok_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2096285285/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2096285285.dir/build.make CMakeFiles/cmTryCompileExec2096285285.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2096285285.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2096285285.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2096285285
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2096285285.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2096285285.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2096285285 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtok_r
  return ((int*)(&strtok_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strftime exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4280066882/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4280066882.dir/build.make CMakeFiles/cmTryCompileExec4280066882.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4280066882.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec4280066882.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4280066882
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4280066882.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec4280066882.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4280066882 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strftime
  return ((int*)(&strftime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the uname exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec897582347/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec897582347.dir/build.make CMakeFiles/cmTryCompileExec897582347.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec897582347.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec897582347.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec897582347
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec897582347.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec897582347.dir/CheckSymbolExists.c.o  -o cmTryCompileExec897582347 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef uname
  return ((int*)(&uname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strcasecmp exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec776492482/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec776492482.dir/build.make CMakeFiles/cmTryCompileExec776492482.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec776492482.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec776492482.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec776492482
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec776492482.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec776492482.dir/CheckSymbolExists.c.o  -o cmTryCompileExec776492482 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strcasecmp
  return ((int*)(&strcasecmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4126009267/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4126009267.dir/build.make CMakeFiles/cmTryCompileExec4126009267.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4126009267.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec4126009267.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4126009267
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4126009267.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec4126009267.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4126009267 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr
  return ((int*)(&gethostbyaddr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gettimeofday exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4284069402/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4284069402.dir/build.make CMakeFiles/cmTryCompileExec4284069402.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4284069402.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec4284069402.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4284069402
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4284069402.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec4284069402.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4284069402 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gettimeofday
  return ((int*)(&gettimeofday))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_addr exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec767055440/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec767055440.dir/build.make CMakeFiles/cmTryCompileExec767055440.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec767055440.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec767055440.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec767055440
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec767055440.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec767055440.dir/CheckSymbolExists.c.o  -o cmTryCompileExec767055440 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_addr
  return ((int*)(&inet_addr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_pton exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3341426179/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3341426179.dir/build.make CMakeFiles/cmTryCompileExec3341426179.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3341426179.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3341426179.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3341426179
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3341426179.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3341426179.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3341426179 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_pton
  return ((int*)(&inet_pton))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the inet_ntoa exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec440155214/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec440155214.dir/build.make CMakeFiles/cmTryCompileExec440155214.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec440155214.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec440155214.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec440155214
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec440155214.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec440155214.dir/CheckSymbolExists.c.o  -o cmTryCompileExec440155214 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef inet_ntoa
  return ((int*)(&inet_ntoa))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcsetattr exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1615580828/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1615580828.dir/build.make CMakeFiles/cmTryCompileExec1615580828.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1615580828.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1615580828.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1615580828
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1615580828.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1615580828.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1615580828 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcsetattr
  return ((int*)(&tcsetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the tcgetattr exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1808016052/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1808016052.dir/build.make CMakeFiles/cmTryCompileExec1808016052.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1808016052.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1808016052.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1808016052
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1808016052.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1808016052.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1808016052 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef tcgetattr
  return ((int*)(&tcgetattr))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the perror exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2495282622/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2495282622.dir/build.make CMakeFiles/cmTryCompileExec2495282622.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2495282622.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2495282622.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2495282622
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2495282622.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2495282622.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2495282622 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef perror
  return ((int*)(&perror))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setvbuf exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec348588083/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec348588083.dir/build.make CMakeFiles/cmTryCompileExec348588083.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec348588083.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec348588083.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec348588083
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec348588083.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec348588083.dir/CheckSymbolExists.c.o  -o cmTryCompileExec348588083 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setvbuf
  return ((int*)(&setvbuf))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigsetjmp exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3936338483/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3936338483.dir/build.make CMakeFiles/cmTryCompileExec3936338483.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3936338483.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3936338483.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3936338483
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3936338483.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3936338483.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3936338483 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigsetjmp
  return ((int*)(&sigsetjmp))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getpwuid exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec478711618/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec478711618.dir/build.make CMakeFiles/cmTryCompileExec478711618.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec478711618.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec478711618.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec478711618
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec478711618.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec478711618.dir/CheckSymbolExists.c.o  -o cmTryCompileExec478711618 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getpwuid
  return ((int*)(&getpwuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the geteuid exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2813423608/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2813423608.dir/build.make CMakeFiles/cmTryCompileExec2813423608.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2813423608.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2813423608.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2813423608
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2813423608.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2813423608.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2813423608 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef geteuid
  return ((int*)(&geteuid))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the utime exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2744289882/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2744289882.dir/build.make CMakeFiles/cmTryCompileExec2744289882.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2744289882.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2744289882.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2744289882
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2744289882.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2744289882.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2744289882 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef utime
  return ((int*)(&utime))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gmtime_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3430511743/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3430511743.dir/build.make CMakeFiles/cmTryCompileExec3430511743.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3430511743.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3430511743.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3430511743
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3430511743.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3430511743.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3430511743 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gmtime_r
  return ((int*)(&gmtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the localtime_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec347356759/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec347356759.dir/build.make CMakeFiles/cmTryCompileExec347356759.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec347356759.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec347356759.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec347356759
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec347356759.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec347356759.dir/CheckSymbolExists.c.o  -o cmTryCompileExec347356759 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef localtime_r
  return ((int*)(&localtime_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3222313212/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3222313212.dir/build.make CMakeFiles/cmTryCompileExec3222313212.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3222313212.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3222313212.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3222313212
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3222313212.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3222313212.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3222313212 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname
  return ((int*)(&gethostbyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyname_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec577119292/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec577119292.dir/build.make CMakeFiles/cmTryCompileExec577119292.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec577119292.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec577119292.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec577119292
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec577119292.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec577119292.dir/CheckSymbolExists.c.o  -o cmTryCompileExec577119292 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyname_r
  return ((int*)(&gethostbyname_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the gethostbyaddr_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec65901450/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec65901450.dir/build.make CMakeFiles/cmTryCompileExec65901450.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec65901450.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec65901450.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec65901450
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec65901450.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec65901450.dir/CheckSymbolExists.c.o  -o cmTryCompileExec65901450 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef gethostbyaddr_r
  return ((int*)(&gethostbyaddr_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the signal exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec103548894/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec103548894.dir/build.make CMakeFiles/cmTryCompileExec103548894.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec103548894.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec103548894.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec103548894
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec103548894.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec103548894.dir/CheckSymbolExists.c.o  -o cmTryCompileExec103548894 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef signal
  return ((int*)(&signal))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIGALRM exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3707635877/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3707635877.dir/build.make CMakeFiles/cmTryCompileExec3707635877.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3707635877.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3707635877.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3707635877
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3707635877.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec3707635877.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3707635877 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIGALRM
  return ((int*)(&SIGALRM))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strtoll exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec249012819/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec249012819.dir/build.make CMakeFiles/cmTryCompileExec249012819.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec249012819.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec249012819.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec249012819
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec249012819.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec249012819.dir/CheckSymbolExists.c.o  -o cmTryCompileExec249012819 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strtoll
  return ((int*)(&strtoll))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the strerror_r exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4209447829/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4209447829.dir/build.make CMakeFiles/cmTryCompileExec4209447829.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4209447829.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec4209447829.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4209447829
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4209447829.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec4209447829.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4209447829 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef strerror_r
  return ((int*)(&strerror_r))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the siginterrupt exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec133665254/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec133665254.dir/build.make CMakeFiles/cmTryCompileExec133665254.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec133665254.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec133665254.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec133665254
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec133665254.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec133665254.dir/CheckSymbolExists.c.o  -o cmTryCompileExec133665254 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef siginterrupt
  return ((int*)(&siginterrupt))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the fork exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec86939096/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec86939096.dir/build.make CMakeFiles/cmTryCompileExec86939096.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec86939096.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec86939096.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec86939096
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec86939096.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec86939096.dir/CheckSymbolExists.c.o  -o cmTryCompileExec86939096 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef fork
  return ((int*)(&fork))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the pipe exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4272905977/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4272905977.dir/build.make CMakeFiles/cmTryCompileExec4272905977.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4272905977.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec4272905977.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec4272905977
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4272905977.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec4272905977.dir/CheckSymbolExists.c.o  -o cmTryCompileExec4272905977 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef pipe
  return ((int*)(&pipe))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the ftruncate exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec216041076/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec216041076.dir/build.make CMakeFiles/cmTryCompileExec216041076.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec216041076.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec216041076.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec216041076
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec216041076.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec216041076.dir/CheckSymbolExists.c.o  -o cmTryCompileExec216041076 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef ftruncate
  return ((int*)(&ftruncate))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getprotobyname exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1672965055/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1672965055.dir/build.make CMakeFiles/cmTryCompileExec1672965055.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1672965055.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1672965055.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1672965055
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1672965055.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1672965055.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1672965055 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getprotobyname
  return ((int*)(&getprotobyname))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the getrlimit exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec468314130/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec468314130.dir/build.make CMakeFiles/cmTryCompileExec468314130.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec468314130.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec468314130.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec468314130
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec468314130.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec468314130.dir/CheckSymbolExists.c.o  -o cmTryCompileExec468314130 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef getrlimit
  return ((int*)(&getrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setlocale exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1625247279/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1625247279.dir/build.make CMakeFiles/cmTryCompileExec1625247279.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1625247279.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1625247279.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1625247279
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1625247279.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1625247279.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1625247279 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setlocale
  return ((int*)(&setlocale))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the setrlimit exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1776080842/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1776080842.dir/build.make CMakeFiles/cmTryCompileExec1776080842.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1776080842.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec1776080842.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1776080842
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1776080842.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec1776080842.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1776080842 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <stdio.h>
#include <stddef.h>
#include <sys/types.h>
#include <inttypes.h>
#include <alloca.h>
#include <arpa/inet.h>
#include <dlfcn.h>
#include <fcntl.h>
#include <malloc.h>
#include <memory.h>
#include <netdb.h>
#include <sys/poll.h>
#include <assert.h>
#include <limits.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <netinet/tcp.h>
#include <sys/select.h>
#include <utime.h>
#include <netinet/in.h>
#include <pwd.h>
#include <sgtty.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <termios.h>
#include <termio.h>
#include <time.h>
#include <unistd.h>
#include <locale.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/utsname.h>
#include <arpa/tftp.h>
#include <errno.h>
#include <libgen.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef setrlimit
  return ((int*)(&setrlimit))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the sigaction exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec866077275/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec866077275.dir/build.make CMakeFiles/cmTryCompileExec866077275.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec866077275.dir/CheckSymbolExists.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec866077275.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec866077275
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec866077275.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec866077275.dir/CheckSymbolExists.c.o  -o cmTryCompileExec866077275 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <signal.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef sigaction
  return ((int*)(&sigaction))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing Curl Test HAVE_O_NONBLOCK passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3313292201/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3313292201.dir/build.make CMakeFiles/cmTryCompileExec3313292201.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3313292201.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_O_NONBLOCK   -o CMakeFiles/cmTryCompileExec3313292201.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3313292201
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3313292201.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_O_NONBLOCK    CMakeFiles/cmTryCompileExec3313292201.dir/CurlTests.c.o  -o cmTryCompileExec3313292201 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test TIME_WITH_SYS_TIME passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec569330248/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec569330248.dir/build.make CMakeFiles/cmTryCompileExec569330248.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec569330248.dir/CurlTests.c.o
/usr/bin/clang   -DTIME_WITH_SYS_TIME   -o CMakeFiles/cmTryCompileExec569330248.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec569330248
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec569330248.dir/link.txt --verbose=1
/usr/bin/clang      -DTIME_WITH_SYS_TIME    CMakeFiles/cmTryCompileExec569330248.dir/CurlTests.c.o  -o cmTryCompileExec569330248 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8 passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3102079868/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3102079868.dir/build.make CMakeFiles/cmTryCompileExec3102079868.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3102079868.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_GETHOSTBYADDR_R_8   -o CMakeFiles/cmTryCompileExec3102079868.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3102079868
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3102079868.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_GETHOSTBYADDR_R_8    CMakeFiles/cmTryCompileExec3102079868.dir/CurlTests.c.o  -o cmTryCompileExec3102079868 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYADDR_R_8_REENTRANT passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec208218549/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec208218549.dir/build.make CMakeFiles/cmTryCompileExec208218549.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec208218549.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_GETHOSTBYADDR_R_8_REENTRANT   -o CMakeFiles/cmTryCompileExec208218549.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec208218549
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec208218549.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_GETHOSTBYADDR_R_8_REENTRANT    CMakeFiles/cmTryCompileExec208218549.dir/CurlTests.c.o  -o cmTryCompileExec208218549 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6 passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec115630595/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec115630595.dir/build.make CMakeFiles/cmTryCompileExec115630595.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec115630595.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_GETHOSTBYNAME_R_6   -o CMakeFiles/cmTryCompileExec115630595.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec115630595
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec115630595.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_GETHOSTBYNAME_R_6    CMakeFiles/cmTryCompileExec115630595.dir/CurlTests.c.o  -o cmTryCompileExec115630595 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETHOSTBYNAME_R_6_REENTRANT passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4107955509/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4107955509.dir/build.make CMakeFiles/cmTryCompileExec4107955509.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4107955509.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_GETHOSTBYNAME_R_6_REENTRANT   -o CMakeFiles/cmTryCompileExec4107955509.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4107955509
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4107955509.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_GETHOSTBYNAME_R_6_REENTRANT    CMakeFiles/cmTryCompileExec4107955509.dir/CurlTests.c.o  -o cmTryCompileExec4107955509 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_SOCKLEN_T passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1933228185/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1933228185.dir/build.make CMakeFiles/cmTryCompileExec1933228185.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1933228185.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_SOCKLEN_T   -o CMakeFiles/cmTryCompileExec1933228185.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec1933228185
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1933228185.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_SOCKLEN_T    CMakeFiles/cmTryCompileExec1933228185.dir/CurlTests.c.o  -o cmTryCompileExec1933228185 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_IN_ADDR_T passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4080599654/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4080599654.dir/build.make CMakeFiles/cmTryCompileExec4080599654.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4080599654.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_IN_ADDR_T   -o CMakeFiles/cmTryCompileExec4080599654.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec4080599654
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4080599654.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_IN_ADDR_T    CMakeFiles/cmTryCompileExec4080599654.dir/CurlTests.c.o  -o cmTryCompileExec4080599654 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test STDC_HEADERS passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2114871165/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2114871165.dir/build.make CMakeFiles/cmTryCompileExec2114871165.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2114871165.dir/CurlTests.c.o
/usr/bin/clang   -DSTDC_HEADERS   -o CMakeFiles/cmTryCompileExec2114871165.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec2114871165
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2114871165.dir/link.txt --verbose=1
/usr/bin/clang      -DSTDC_HEADERS    CMakeFiles/cmTryCompileExec2114871165.dir/CurlTests.c.o  -o cmTryCompileExec2114871165 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test RETSIGTYPE_TEST passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec704423351/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec704423351.dir/build.make CMakeFiles/cmTryCompileExec704423351.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec704423351.dir/CurlTests.c.o
/usr/bin/clang   -DRETSIGTYPE_TEST   -o CMakeFiles/cmTryCompileExec704423351.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec704423351
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec704423351.dir/link.txt --verbose=1
/usr/bin/clang      -DRETSIGTYPE_TEST    CMakeFiles/cmTryCompileExec704423351.dir/CurlTests.c.o  -o cmTryCompileExec704423351 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_GETADDRINFO passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4156787718/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4156787718.dir/build.make CMakeFiles/cmTryCompileExec4156787718.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4156787718.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_GETADDRINFO   -o CMakeFiles/cmTryCompileExec4156787718.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c:405:5: warning: implicitly declaring library function 'memset' with type 'void *(void *, int, unsigned long)'
    memset(&hints, 0, sizeof(hints));
    ^
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c:405:5: note: please include the header <string.h> or explicitly provide a declaration for 'memset'
1 warning generated.
Linking C executable cmTryCompileExec4156787718
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4156787718.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_GETADDRINFO    CMakeFiles/cmTryCompileExec4156787718.dir/CurlTests.c.o  -o cmTryCompileExec4156787718 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Performing Curl Test HAVE_FILE_OFFSET_BITS passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3183030833/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3183030833.dir/build.make CMakeFiles/cmTryCompileExec3183030833.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3183030833.dir/CurlTests.c.o
/usr/bin/clang   -DHAVE_FILE_OFFSET_BITS   -o CMakeFiles/cmTryCompileExec3183030833.dir/CurlTests.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmcurl/CMake/CurlTests.c
Linking C executable cmTryCompileExec3183030833
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3183030833.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_FILE_OFFSET_BITS    CMakeFiles/cmTryCompileExec3183030833.dir/CurlTests.c.o  -o cmTryCompileExec3183030833 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Determining size of curl_off_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec771480065/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec771480065.dir/build.make CMakeFiles/cmTryCompileExec771480065.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec771480065.dir/SIZEOF_CURL_OFF_T.c.o
/usr/bin/clang   -D_FILE_OFFSET_BITS=64   -o CMakeFiles/cmTryCompileExec771480065.dir/SIZEOF_CURL_OFF_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_CURL_OFF_T.c
Linking C executable cmTryCompileExec771480065
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec771480065.dir/link.txt --verbose=1
/usr/bin/clang      -D_FILE_OFFSET_BITS=64    CMakeFiles/cmTryCompileExec771480065.dir/SIZEOF_CURL_OFF_T.c.o  -o cmTryCompileExec771480065 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test curl_cv_recv succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1590980373/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1590980373.dir/build.make CMakeFiles/cmTryCompileExec1590980373.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1590980373.dir/src.c.o
/usr/bin/clang   -Dcurl_cv_recv   -o CMakeFiles/cmTryCompileExec1590980373.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1590980373
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1590980373.dir/link.txt --verbose=1
/usr/bin/clang      -Dcurl_cv_recv    CMakeFiles/cmTryCompileExec1590980373.dir/src.c.o  -o cmTryCompileExec1590980373 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>

#define __unused5 1

int main() { recv(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t recv(int, void *, size_t, int) (curl_cv_func_recv_test) succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2687962159/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2687962159.dir/build.make CMakeFiles/cmTryCompileExec2687962159.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2687962159.dir/src.c.o
/usr/bin/clang   -Dcurl_cv_func_recv_test   -o CMakeFiles/cmTryCompileExec2687962159.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2687962159
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2687962159.dir/link.txt --verbose=1
/usr/bin/clang      -Dcurl_cv_func_recv_test    CMakeFiles/cmTryCompileExec2687962159.dir/src.c.o  -o cmTryCompileExec2687962159 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = recv(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test curl_cv_send succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1531338293/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1531338293.dir/build.make CMakeFiles/cmTryCompileExec1531338293.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1531338293.dir/src.c.o
/usr/bin/clang   -Dcurl_cv_send   -o CMakeFiles/cmTryCompileExec1531338293.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1531338293
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1531338293.dir/link.txt --verbose=1
/usr/bin/clang      -Dcurl_cv_send    CMakeFiles/cmTryCompileExec1531338293.dir/src.c.o  -o cmTryCompileExec1531338293 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  recv(int, void *, size_t, int);
#define __unused5 1

int main() { send(0, 0, 0, 0) ; return 0; }
Performing C SOURCE FILE Test ssize_t send(int, const void *, size_t, int) (curl_cv_func_send_test) succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec62953759/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec62953759.dir/build.make CMakeFiles/cmTryCompileExec62953759.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec62953759.dir/src.c.o
/usr/bin/clang   -Dcurl_cv_func_send_test   -o CMakeFiles/cmTryCompileExec62953759.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec62953759
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec62953759.dir/link.txt --verbose=1
/usr/bin/clang      -Dcurl_cv_func_send_test    CMakeFiles/cmTryCompileExec62953759.dir/src.c.o  -o cmTryCompileExec62953759 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5 1

int main() { 
                    int s=0;
                    const void * buf=0;
                    size_t len=0;
                    int flags=0;
                    ssize_t res = send(s, buf, len, flags) ; return 0; }
Performing C SOURCE FILE Test HAVE_MSG_NOSIGNAL succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1027225163/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1027225163.dir/build.make CMakeFiles/cmTryCompileExec1027225163.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1027225163.dir/src.c.o
/usr/bin/clang   -DHAVE_MSG_NOSIGNAL   -o CMakeFiles/cmTryCompileExec1027225163.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c:12:9: warning: '__unused5' macro redefined
#define __unused5 1
        ^
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c:8:9: note: previous definition is here
#define __unused5
        ^
1 warning generated.
Linking C executable cmTryCompileExec1027225163
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1027225163.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_MSG_NOSIGNAL    CMakeFiles/cmTryCompileExec1027225163.dir/src.c.o  -o cmTryCompileExec1027225163 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/socket.h>
extern ssize_t  send(int, const void *, size_t, int);
#define __unused5

#include <sys/types.h>
#include <sys/socket.h>
#define __unused5 1

int main() { int flag = MSG_NOSIGNAL ; return 0; }
Performing C SOURCE FILE Test HAVE_STRUCT_TIMEVAL succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2494442398/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2494442398.dir/build.make CMakeFiles/cmTryCompileExec2494442398.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2494442398.dir/src.c.o
/usr/bin/clang   -DHAVE_STRUCT_TIMEVAL   -o CMakeFiles/cmTryCompileExec2494442398.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec2494442398
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2494442398.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_STRUCT_TIMEVAL    CMakeFiles/cmTryCompileExec2494442398.dir/src.c.o  -o cmTryCompileExec2494442398 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __unused1
#undef inline
#define __unused2

#include <sys/types.h>
#include <sys/time.h>
#include <time.h>
#include <time.h>
#define __unused5 1

int main() { struct timeval ts;
ts.tv_sec  = 0;
ts.tv_usec = 0 ; return 0; }
Determining size of sig_atomic_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2966494483/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2966494483.dir/build.make CMakeFiles/cmTryCompileExec2966494483.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2966494483.dir/SIZEOF_SIG_ATOMIC_T.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2966494483.dir/SIZEOF_SIG_ATOMIC_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_SIG_ATOMIC_T.c
Linking C executable cmTryCompileExec2966494483
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2966494483.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2966494483.dir/SIZEOF_SIG_ATOMIC_T.c.o  -o cmTryCompileExec2966494483 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_SIG_ATOMIC_T_NOT_VOLATILE succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3596507238/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3596507238.dir/build.make CMakeFiles/cmTryCompileExec3596507238.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3596507238.dir/src.c.o
/usr/bin/clang   -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE   -o CMakeFiles/cmTryCompileExec3596507238.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec3596507238
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3596507238.dir/link.txt --verbose=1
/usr/bin/clang      -DHAVE_SIG_ATOMIC_T_NOT_VOLATILE    CMakeFiles/cmTryCompileExec3596507238.dir/src.c.o  -o cmTryCompileExec3596507238 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <signal.h>

int main() { static volatile sig_atomic_t dummy = 0 ; return 0; }
Determining size of struct sockaddr_storage passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2205464375/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2205464375.dir/build.make CMakeFiles/cmTryCompileExec2205464375.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2205464375.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec2205464375.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_STRUCT_SOCKADDR_STORAGE.c
Linking C executable cmTryCompileExec2205464375
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2205464375.dir/link.txt --verbose=1
/usr/bin/clang          CMakeFiles/cmTryCompileExec2205464375.dir/SIZEOF_STRUCT_SOCKADDR_STORAGE.c.o  -o cmTryCompileExec2205464375 -rdynamic -ldl 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_DIRENT_H succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec391037970/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec391037970.dir/build.make CMakeFiles/cmTryCompileExec391037970.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec391037970.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_DIRENT_H   -o CMakeFiles/cmTryCompileExec391037970.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec391037970
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec391037970.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_DIRENT_H    CMakeFiles/cmTryCompileExec391037970.dir/src.c.o  -o cmTryCompileExec391037970 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <dirent.h>

int main()
{
   static DIR * tmp;
   if (sizeof(tmp))
      return 0;
  return 0;
}

Determining if files sys/types.h;ctype.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec14118974/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec14118974.dir/build.make CMakeFiles/cmTryCompileExec14118974.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec14118974.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec14118974.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec14118974
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec14118974.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec14118974.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec14118974 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3365307743/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3365307743.dir/build.make CMakeFiles/cmTryCompileExec3365307743.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3365307743.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3365307743.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3365307743
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3365307743.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3365307743.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3365307743 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3878115432/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3878115432.dir/build.make CMakeFiles/cmTryCompileExec3878115432.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3878115432.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3878115432.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3878115432
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3878115432.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3878115432.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3878115432 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec322075440/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec322075440.dir/build.make CMakeFiles/cmTryCompileExec322075440.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec322075440.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec322075440.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec322075440
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec322075440.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec322075440.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec322075440 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3897593262/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3897593262.dir/build.make CMakeFiles/cmTryCompileExec3897593262.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3897593262.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3897593262.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3897593262
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3897593262.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3897593262.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3897593262 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1114429079/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1114429079.dir/build.make CMakeFiles/cmTryCompileExec1114429079.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1114429079.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1114429079.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1114429079
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1114429079.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1114429079.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1114429079 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2226812105/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2226812105.dir/build.make CMakeFiles/cmTryCompileExec2226812105.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2226812105.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2226812105.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2226812105
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2226812105.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2226812105.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2226812105 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3248671451/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3248671451.dir/build.make CMakeFiles/cmTryCompileExec3248671451.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3248671451.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3248671451.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3248671451
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3248671451.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3248671451.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3248671451 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3004727196/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3004727196.dir/build.make CMakeFiles/cmTryCompileExec3004727196.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3004727196.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3004727196.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3004727196
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3004727196.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3004727196.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3004727196 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2684064473/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2684064473.dir/build.make CMakeFiles/cmTryCompileExec2684064473.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2684064473.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2684064473.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2684064473
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2684064473.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2684064473.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2684064473 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2244596627/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2244596627.dir/build.make CMakeFiles/cmTryCompileExec2244596627.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2244596627.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2244596627.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2244596627
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2244596627.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2244596627.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2244596627 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2147133088/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2147133088.dir/build.make CMakeFiles/cmTryCompileExec2147133088.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2147133088.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2147133088.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2147133088
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2147133088.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2147133088.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2147133088 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1874325366/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1874325366.dir/build.make CMakeFiles/cmTryCompileExec1874325366.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1874325366.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1874325366.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1874325366
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1874325366.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1874325366.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1874325366 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1447016443/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1447016443.dir/build.make CMakeFiles/cmTryCompileExec1447016443.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1447016443.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1447016443.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1447016443
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1447016443.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1447016443.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1447016443 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3895541551/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3895541551.dir/build.make CMakeFiles/cmTryCompileExec3895541551.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3895541551.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3895541551.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3895541551
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3895541551.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3895541551.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3895541551 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2202197704/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2202197704.dir/build.make CMakeFiles/cmTryCompileExec2202197704.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2202197704.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2202197704.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec2202197704
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2202197704.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2202197704.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec2202197704 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1109986540/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1109986540.dir/build.make CMakeFiles/cmTryCompileExec1109986540.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1109986540.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1109986540.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec1109986540
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1109986540.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1109986540.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec1109986540 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if files sys/types.h;ctype.h;dlfcn.h;errno.h;fcntl.h;grp.h;inttypes.h;langinfo.h;limits.h;linux/types.h;linux/fiemap.h;linux/fs.h;linux/magic.h;locale.h;memory.h;paths.h;poll.h;pwd.h;regex.h;signal.h;stdarg.h;stdint.h;stdlib.h;string.h;strings.h;sys/cdefs.h;sys/ioctl.h;sys/param.h;sys/poll.h;sys/select.h;sys/stat.h;sys/statfs.h;sys/statvfs.h;sys/time.h;sys/utsname.h;sys/vfs.h;sys/wait.h;time.h;unistd.h;utime.h;wchar.h;wctype.h exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3103550934/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3103550934.dir/build.make CMakeFiles/cmTryCompileExec3103550934.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3103550934.dir/CheckIncludeFiles.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3103550934.dir/CheckIncludeFiles.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFiles.c
Linking C executable cmTryCompileExec3103550934
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3103550934.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3103550934.dir/CheckIncludeFiles.c.o  -o cmTryCompileExec3103550934 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test SAFE_TO_DEFINE_EXTENSIONS succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec373245165/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec373245165.dir/build.make CMakeFiles/cmTryCompileExec373245165.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec373245165.dir/src.c.o
/usr/bin/clang   -w  -DSAFE_TO_DEFINE_EXTENSIONS   -o CMakeFiles/cmTryCompileExec373245165.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec373245165
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec373245165.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DSAFE_TO_DEFINE_EXTENSIONS    CMakeFiles/cmTryCompileExec373245165.dir/src.c.o  -o cmTryCompileExec373245165 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#define __EXTENSIONS__ 1
   
   int main() { return 0;}
Determining if the function chown exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec78983235/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec78983235.dir/build.make CMakeFiles/cmTryCompileExec78983235.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec78983235.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=chown   -o CMakeFiles/cmTryCompileExec78983235.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec78983235
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec78983235.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=chown    CMakeFiles/cmTryCompileExec78983235.dir/CheckFunctionExists.c.o  -o cmTryCompileExec78983235 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function chroot exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec379885036/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec379885036.dir/build.make CMakeFiles/cmTryCompileExec379885036.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec379885036.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=chroot   -o CMakeFiles/cmTryCompileExec379885036.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec379885036
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec379885036.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=chroot    CMakeFiles/cmTryCompileExec379885036.dir/CheckFunctionExists.c.o  -o cmTryCompileExec379885036 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function ctime_r exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2402557800/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2402557800.dir/build.make CMakeFiles/cmTryCompileExec2402557800.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2402557800.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=ctime_r   -o CMakeFiles/cmTryCompileExec2402557800.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2402557800
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2402557800.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=ctime_r    CMakeFiles/cmTryCompileExec2402557800.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2402557800 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchdir exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec633303489/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec633303489.dir/build.make CMakeFiles/cmTryCompileExec633303489.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec633303489.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fchdir   -o CMakeFiles/cmTryCompileExec633303489.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec633303489
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec633303489.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fchdir    CMakeFiles/cmTryCompileExec633303489.dir/CheckFunctionExists.c.o  -o cmTryCompileExec633303489 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchmod exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2143284415/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2143284415.dir/build.make CMakeFiles/cmTryCompileExec2143284415.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2143284415.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fchmod   -o CMakeFiles/cmTryCompileExec2143284415.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2143284415
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2143284415.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fchmod    CMakeFiles/cmTryCompileExec2143284415.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2143284415 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fchown exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1955973753/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1955973753.dir/build.make CMakeFiles/cmTryCompileExec1955973753.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1955973753.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fchown   -o CMakeFiles/cmTryCompileExec1955973753.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1955973753
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1955973753.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fchown    CMakeFiles/cmTryCompileExec1955973753.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1955973753 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fcntl exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1266462486/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1266462486.dir/build.make CMakeFiles/cmTryCompileExec1266462486.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1266462486.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fcntl   -o CMakeFiles/cmTryCompileExec1266462486.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1266462486
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1266462486.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fcntl    CMakeFiles/cmTryCompileExec1266462486.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1266462486 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fdopendir exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3387333235/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3387333235.dir/build.make CMakeFiles/cmTryCompileExec3387333235.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3387333235.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fdopendir   -o CMakeFiles/cmTryCompileExec3387333235.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3387333235
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3387333235.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fdopendir    CMakeFiles/cmTryCompileExec3387333235.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3387333235 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3978164390/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3978164390.dir/build.make CMakeFiles/cmTryCompileExec3978164390.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3978164390.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fstat   -o CMakeFiles/cmTryCompileExec3978164390.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3978164390
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3978164390.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fstat    CMakeFiles/cmTryCompileExec3978164390.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3978164390 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4041608578/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4041608578.dir/build.make CMakeFiles/cmTryCompileExec4041608578.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4041608578.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fstatat   -o CMakeFiles/cmTryCompileExec4041608578.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec4041608578
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4041608578.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fstatat    CMakeFiles/cmTryCompileExec4041608578.dir/CheckFunctionExists.c.o  -o cmTryCompileExec4041608578 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatfs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1192096905/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1192096905.dir/build.make CMakeFiles/cmTryCompileExec1192096905.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1192096905.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fstatfs   -o CMakeFiles/cmTryCompileExec1192096905.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1192096905
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1192096905.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fstatfs    CMakeFiles/cmTryCompileExec1192096905.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1192096905 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fstatvfs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1620271822/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1620271822.dir/build.make CMakeFiles/cmTryCompileExec1620271822.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1620271822.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fstatvfs   -o CMakeFiles/cmTryCompileExec1620271822.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1620271822
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1620271822.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fstatvfs    CMakeFiles/cmTryCompileExec1620271822.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1620271822 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimens exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1247523309/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1247523309.dir/build.make CMakeFiles/cmTryCompileExec1247523309.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1247523309.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=futimens   -o CMakeFiles/cmTryCompileExec1247523309.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1247523309
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1247523309.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=futimens    CMakeFiles/cmTryCompileExec1247523309.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1247523309 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimes exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2459987432/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2459987432.dir/build.make CMakeFiles/cmTryCompileExec2459987432.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2459987432.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=futimes   -o CMakeFiles/cmTryCompileExec2459987432.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2459987432
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2459987432.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=futimes    CMakeFiles/cmTryCompileExec2459987432.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2459987432 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function futimesat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1292644232/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1292644232.dir/build.make CMakeFiles/cmTryCompileExec1292644232.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1292644232.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=futimesat   -o CMakeFiles/cmTryCompileExec1292644232.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1292644232
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1292644232.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=futimesat    CMakeFiles/cmTryCompileExec1292644232.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1292644232 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getgrgid_r exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2847751186/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2847751186.dir/build.make CMakeFiles/cmTryCompileExec2847751186.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2847751186.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r   -o CMakeFiles/cmTryCompileExec2847751186.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2847751186
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2847751186.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=getgrgid_r    CMakeFiles/cmTryCompileExec2847751186.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2847751186 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getgrnam_r exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2813603724/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2813603724.dir/build.make CMakeFiles/cmTryCompileExec2813603724.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2813603724.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r   -o CMakeFiles/cmTryCompileExec2813603724.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2813603724
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2813603724.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=getgrnam_r    CMakeFiles/cmTryCompileExec2813603724.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2813603724 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpwnam_r exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3850497942/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3850497942.dir/build.make CMakeFiles/cmTryCompileExec3850497942.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3850497942.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r   -o CMakeFiles/cmTryCompileExec3850497942.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3850497942
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3850497942.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=getpwnam_r    CMakeFiles/cmTryCompileExec3850497942.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3850497942 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpwuid_r exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec167132960/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec167132960.dir/build.make CMakeFiles/cmTryCompileExec167132960.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec167132960.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r   -o CMakeFiles/cmTryCompileExec167132960.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec167132960
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec167132960.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=getpwuid_r    CMakeFiles/cmTryCompileExec167132960.dir/CheckFunctionExists.c.o  -o cmTryCompileExec167132960 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function getpid exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec304173149/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec304173149.dir/build.make CMakeFiles/cmTryCompileExec304173149.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec304173149.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=getpid   -o CMakeFiles/cmTryCompileExec304173149.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec304173149
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec304173149.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=getpid    CMakeFiles/cmTryCompileExec304173149.dir/CheckFunctionExists.c.o  -o cmTryCompileExec304173149 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lchown exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1689390729/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1689390729.dir/build.make CMakeFiles/cmTryCompileExec1689390729.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1689390729.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=lchown   -o CMakeFiles/cmTryCompileExec1689390729.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1689390729
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1689390729.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=lchown    CMakeFiles/cmTryCompileExec1689390729.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1689390729 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function link exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3589554711/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3589554711.dir/build.make CMakeFiles/cmTryCompileExec3589554711.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3589554711.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=link   -o CMakeFiles/cmTryCompileExec3589554711.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3589554711
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3589554711.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=link    CMakeFiles/cmTryCompileExec3589554711.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3589554711 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lstat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3361572306/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3361572306.dir/build.make CMakeFiles/cmTryCompileExec3361572306.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3361572306.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=lstat   -o CMakeFiles/cmTryCompileExec3361572306.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3361572306
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3361572306.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=lstat    CMakeFiles/cmTryCompileExec3361572306.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3361572306 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function lutimes exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1119163220/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1119163220.dir/build.make CMakeFiles/cmTryCompileExec1119163220.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1119163220.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=lutimes   -o CMakeFiles/cmTryCompileExec1119163220.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1119163220
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1119163220.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=lutimes    CMakeFiles/cmTryCompileExec1119163220.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1119163220 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mbrtowc exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec601909780/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec601909780.dir/build.make CMakeFiles/cmTryCompileExec601909780.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec601909780.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mbrtowc   -o CMakeFiles/cmTryCompileExec601909780.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec601909780
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec601909780.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mbrtowc    CMakeFiles/cmTryCompileExec601909780.dir/CheckFunctionExists.c.o  -o cmTryCompileExec601909780 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mbsnrtowcs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3870690790/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3870690790.dir/build.make CMakeFiles/cmTryCompileExec3870690790.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3870690790.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs   -o CMakeFiles/cmTryCompileExec3870690790.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3870690790
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3870690790.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mbsnrtowcs    CMakeFiles/cmTryCompileExec3870690790.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3870690790 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function memmove exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2160660791/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2160660791.dir/build.make CMakeFiles/cmTryCompileExec2160660791.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2160660791.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=memmove   -o CMakeFiles/cmTryCompileExec2160660791.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2160660791
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2160660791.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=memmove    CMakeFiles/cmTryCompileExec2160660791.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2160660791 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkdir exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1215699374/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1215699374.dir/build.make CMakeFiles/cmTryCompileExec1215699374.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1215699374.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mkdir   -o CMakeFiles/cmTryCompileExec1215699374.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1215699374
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1215699374.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mkdir    CMakeFiles/cmTryCompileExec1215699374.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1215699374 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkfifo exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3531070318/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3531070318.dir/build.make CMakeFiles/cmTryCompileExec3531070318.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3531070318.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mkfifo   -o CMakeFiles/cmTryCompileExec3531070318.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3531070318
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3531070318.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mkfifo    CMakeFiles/cmTryCompileExec3531070318.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3531070318 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mknod exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1365845572/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1365845572.dir/build.make CMakeFiles/cmTryCompileExec1365845572.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1365845572.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mknod   -o CMakeFiles/cmTryCompileExec1365845572.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1365845572
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1365845572.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mknod    CMakeFiles/cmTryCompileExec1365845572.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1365845572 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function mkstemp exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec774231464/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec774231464.dir/build.make CMakeFiles/cmTryCompileExec774231464.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec774231464.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=mkstemp   -o CMakeFiles/cmTryCompileExec774231464.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec774231464
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec774231464.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=mkstemp    CMakeFiles/cmTryCompileExec774231464.dir/CheckFunctionExists.c.o  -o cmTryCompileExec774231464 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function nl_langinfo exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec30569729/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec30569729.dir/build.make CMakeFiles/cmTryCompileExec30569729.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec30569729.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo   -o CMakeFiles/cmTryCompileExec30569729.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec30569729
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec30569729.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=nl_langinfo    CMakeFiles/cmTryCompileExec30569729.dir/CheckFunctionExists.c.o  -o cmTryCompileExec30569729 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function openat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2575780345/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2575780345.dir/build.make CMakeFiles/cmTryCompileExec2575780345.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2575780345.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=openat   -o CMakeFiles/cmTryCompileExec2575780345.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2575780345
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2575780345.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=openat    CMakeFiles/cmTryCompileExec2575780345.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2575780345 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function readlink exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2631585374/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2631585374.dir/build.make CMakeFiles/cmTryCompileExec2631585374.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2631585374.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=readlink   -o CMakeFiles/cmTryCompileExec2631585374.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2631585374
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2631585374.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=readlink    CMakeFiles/cmTryCompileExec2631585374.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2631585374 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function setenv exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2402185043/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2402185043.dir/build.make CMakeFiles/cmTryCompileExec2402185043.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2402185043.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=setenv   -o CMakeFiles/cmTryCompileExec2402185043.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2402185043
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2402185043.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=setenv    CMakeFiles/cmTryCompileExec2402185043.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2402185043 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function statfs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3769728422/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3769728422.dir/build.make CMakeFiles/cmTryCompileExec3769728422.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3769728422.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=statfs   -o CMakeFiles/cmTryCompileExec3769728422.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3769728422
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3769728422.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=statfs    CMakeFiles/cmTryCompileExec3769728422.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3769728422 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function statvfs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3329042845/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3329042845.dir/build.make CMakeFiles/cmTryCompileExec3329042845.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3329042845.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=statvfs   -o CMakeFiles/cmTryCompileExec3329042845.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3329042845
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3329042845.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=statvfs    CMakeFiles/cmTryCompileExec3329042845.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3329042845 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strchr exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2999095246/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2999095246.dir/build.make CMakeFiles/cmTryCompileExec2999095246.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2999095246.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=strchr   -o CMakeFiles/cmTryCompileExec2999095246.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2999095246
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2999095246.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=strchr    CMakeFiles/cmTryCompileExec2999095246.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2999095246 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strerror exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2735254470/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2735254470.dir/build.make CMakeFiles/cmTryCompileExec2735254470.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2735254470.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=strerror   -o CMakeFiles/cmTryCompileExec2735254470.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2735254470
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2735254470.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=strerror    CMakeFiles/cmTryCompileExec2735254470.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2735254470 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function strrchr exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1058268357/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1058268357.dir/build.make CMakeFiles/cmTryCompileExec1058268357.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1058268357.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=strrchr   -o CMakeFiles/cmTryCompileExec1058268357.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1058268357
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1058268357.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=strrchr    CMakeFiles/cmTryCompileExec1058268357.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1058268357 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function symlink exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3497567099/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3497567099.dir/build.make CMakeFiles/cmTryCompileExec3497567099.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3497567099.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=symlink   -o CMakeFiles/cmTryCompileExec3497567099.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3497567099
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3497567099.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=symlink    CMakeFiles/cmTryCompileExec3497567099.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3497567099 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function timegm exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3241927257/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3241927257.dir/build.make CMakeFiles/cmTryCompileExec3241927257.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3241927257.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=timegm   -o CMakeFiles/cmTryCompileExec3241927257.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3241927257
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3241927257.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=timegm    CMakeFiles/cmTryCompileExec3241927257.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3241927257 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function tzset exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2286289411/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2286289411.dir/build.make CMakeFiles/cmTryCompileExec2286289411.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2286289411.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=tzset   -o CMakeFiles/cmTryCompileExec2286289411.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2286289411
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2286289411.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=tzset    CMakeFiles/cmTryCompileExec2286289411.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2286289411 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function utimes exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1168431325/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1168431325.dir/build.make CMakeFiles/cmTryCompileExec1168431325.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1168431325.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=utimes   -o CMakeFiles/cmTryCompileExec1168431325.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1168431325
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1168431325.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=utimes    CMakeFiles/cmTryCompileExec1168431325.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1168431325 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function utimensat exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec577642587/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec577642587.dir/build.make CMakeFiles/cmTryCompileExec577642587.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec577642587.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=utimensat   -o CMakeFiles/cmTryCompileExec577642587.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec577642587
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec577642587.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=utimensat    CMakeFiles/cmTryCompileExec577642587.dir/CheckFunctionExists.c.o  -o cmTryCompileExec577642587 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function vfork exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec67875223/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec67875223.dir/build.make CMakeFiles/cmTryCompileExec67875223.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec67875223.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=vfork   -o CMakeFiles/cmTryCompileExec67875223.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec67875223
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec67875223.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=vfork    CMakeFiles/cmTryCompileExec67875223.dir/CheckFunctionExists.c.o  -o cmTryCompileExec67875223 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcrtomb exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec402406456/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec402406456.dir/build.make CMakeFiles/cmTryCompileExec402406456.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec402406456.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wcrtomb   -o CMakeFiles/cmTryCompileExec402406456.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec402406456
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec402406456.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wcrtomb    CMakeFiles/cmTryCompileExec402406456.dir/CheckFunctionExists.c.o  -o cmTryCompileExec402406456 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcscmp exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec412350853/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec412350853.dir/build.make CMakeFiles/cmTryCompileExec412350853.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec412350853.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wcscmp   -o CMakeFiles/cmTryCompileExec412350853.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec412350853
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec412350853.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wcscmp    CMakeFiles/cmTryCompileExec412350853.dir/CheckFunctionExists.c.o  -o cmTryCompileExec412350853 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcscpy exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3381584202/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3381584202.dir/build.make CMakeFiles/cmTryCompileExec3381584202.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3381584202.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wcscpy   -o CMakeFiles/cmTryCompileExec3381584202.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3381584202
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3381584202.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wcscpy    CMakeFiles/cmTryCompileExec3381584202.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3381584202 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcslen exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec565462757/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec565462757.dir/build.make CMakeFiles/cmTryCompileExec565462757.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec565462757.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wcslen   -o CMakeFiles/cmTryCompileExec565462757.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec565462757
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec565462757.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wcslen    CMakeFiles/cmTryCompileExec565462757.dir/CheckFunctionExists.c.o  -o cmTryCompileExec565462757 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wcsnrtombs exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1202409779/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1202409779.dir/build.make CMakeFiles/cmTryCompileExec1202409779.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1202409779.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs   -o CMakeFiles/cmTryCompileExec1202409779.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec1202409779
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1202409779.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wcsnrtombs    CMakeFiles/cmTryCompileExec1202409779.dir/CheckFunctionExists.c.o  -o cmTryCompileExec1202409779 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wctomb exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3054688088/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3054688088.dir/build.make CMakeFiles/cmTryCompileExec3054688088.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3054688088.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wctomb   -o CMakeFiles/cmTryCompileExec3054688088.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3054688088
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3054688088.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wctomb    CMakeFiles/cmTryCompileExec3054688088.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3054688088 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function fseeko exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2815703293/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2815703293.dir/build.make CMakeFiles/cmTryCompileExec2815703293.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2815703293.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=fseeko   -o CMakeFiles/cmTryCompileExec2815703293.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2815703293
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2815703293.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=fseeko    CMakeFiles/cmTryCompileExec2815703293.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2815703293 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function vprintf exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec600816457/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec600816457.dir/build.make CMakeFiles/cmTryCompileExec600816457.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec600816457.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=vprintf   -o CMakeFiles/cmTryCompileExec600816457.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec600816457
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec600816457.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=vprintf    CMakeFiles/cmTryCompileExec600816457.dir/CheckFunctionExists.c.o  -o cmTryCompileExec600816457 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wmemcmp exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3851475456/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3851475456.dir/build.make CMakeFiles/cmTryCompileExec3851475456.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3851475456.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wmemcmp   -o CMakeFiles/cmTryCompileExec3851475456.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec3851475456
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3851475456.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wmemcmp    CMakeFiles/cmTryCompileExec3851475456.dir/CheckFunctionExists.c.o  -o cmTryCompileExec3851475456 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wmemcpy exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2686566464/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2686566464.dir/build.make CMakeFiles/cmTryCompileExec2686566464.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2686566464.dir/CheckFunctionExists.c.o
/usr/bin/clang   -w  -DCHECK_FUNCTION_EXISTS=wmemcpy   -o CMakeFiles/cmTryCompileExec2686566464.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2686566464
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2686566464.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DCHECK_FUNCTION_EXISTS=wmemcpy    CMakeFiles/cmTryCompileExec2686566464.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2686566464 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Performing C SOURCE FILE Test HAVE_READDIR_R succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1414880913/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1414880913.dir/build.make CMakeFiles/cmTryCompileExec1414880913.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1414880913.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_READDIR_R   -o CMakeFiles/cmTryCompileExec1414880913.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1414880913
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1414880913.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_READDIR_R    CMakeFiles/cmTryCompileExec1414880913.dir/src.c.o  -o cmTryCompileExec1414880913 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <dirent.h>
int main() {DIR *d = opendir("."); struct dirent e,*r; return readdir_r(d,&e,&r);}
Performing C SOURCE FILE Test HAVE_READLINKAT succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1337480922/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1337480922.dir/build.make CMakeFiles/cmTryCompileExec1337480922.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1337480922.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_READLINKAT   -o CMakeFiles/cmTryCompileExec1337480922.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec1337480922
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1337480922.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_READLINKAT    CMakeFiles/cmTryCompileExec1337480922.dir/src.c.o  -o cmTryCompileExec1337480922 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <fcntl.h>
#include <unistd.h>
int main() {char buf[10]; return readlinkat(AT_FDCWD, "", buf, 0);}
Performing C SOURCE FILE Test MAJOR_IN_SYSMACROS succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4250326227/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4250326227.dir/build.make CMakeFiles/cmTryCompileExec4250326227.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4250326227.dir/src.c.o
/usr/bin/clang   -w  -DMAJOR_IN_SYSMACROS   -o CMakeFiles/cmTryCompileExec4250326227.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4250326227
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4250326227.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DMAJOR_IN_SYSMACROS    CMakeFiles/cmTryCompileExec4250326227.dir/src.c.o  -o cmTryCompileExec4250326227 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:
#include <sys/sysmacros.h>
int main() { return major(256); }
Determining if the EILSEQ exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2504453349/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2504453349.dir/build.make CMakeFiles/cmTryCompileExec2504453349.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2504453349.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2504453349.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2504453349
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2504453349.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2504453349.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2504453349 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <errno.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef EILSEQ
  return ((int*)(&EILSEQ))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MAX exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1974451910/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1974451910.dir/build.make CMakeFiles/cmTryCompileExec1974451910.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1974451910.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1974451910.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1974451910
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1974451910.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1974451910.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1974451910 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MAX
  return ((int*)(&INT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the INT64_MIN exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1087496532/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1087496532.dir/build.make CMakeFiles/cmTryCompileExec1087496532.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1087496532.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1087496532.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1087496532
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1087496532.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1087496532.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1087496532 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef INT64_MIN
  return ((int*)(&INT64_MIN))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT32_MAX exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1320270007/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1320270007.dir/build.make CMakeFiles/cmTryCompileExec1320270007.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1320270007.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1320270007.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1320270007
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1320270007.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1320270007.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1320270007 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT32_MAX
  return ((int*)(&UINT32_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the UINT64_MAX exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1052820651/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1052820651.dir/build.make CMakeFiles/cmTryCompileExec1052820651.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1052820651.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1052820651.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec1052820651
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1052820651.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1052820651.dir/CheckSymbolExists.c.o  -o cmTryCompileExec1052820651 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef UINT64_MAX
  return ((int*)(&UINT64_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SIZE_MAX exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3611084926/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3611084926.dir/build.make CMakeFiles/cmTryCompileExec3611084926.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3611084926.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3611084926.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec3611084926
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3611084926.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3611084926.dir/CheckSymbolExists.c.o  -o cmTryCompileExec3611084926 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>
#include <stdint.h>
#include <inttypes.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SIZE_MAX
  return ((int*)(&SIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Determining if the SSIZE_MAX exist passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2473919297/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2473919297.dir/build.make CMakeFiles/cmTryCompileExec2473919297.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2473919297.dir/CheckSymbolExists.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2473919297.dir/CheckSymbolExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c
Linking C executable cmTryCompileExec2473919297
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2473919297.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2473919297.dir/CheckSymbolExists.c.o  -o cmTryCompileExec2473919297 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

File /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckSymbolExists.c:
/* */
#include <limits.h>

int main(int argc, char** argv)
{
  (void)argv;
#ifndef SSIZE_MAX
  return ((int*)(&SSIZE_MAX))[argc];
#else
  (void)argc;
  return 0;
#endif
}

Performing C SOURCE FILE Test HAVE_STRUCT_TM_TM_GMTOFF succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec395731180/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec395731180.dir/build.make CMakeFiles/cmTryCompileExec395731180.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec395731180.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_STRUCT_TM_TM_GMTOFF   -o CMakeFiles/cmTryCompileExec395731180.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec395731180
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec395731180.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_STRUCT_TM_TM_GMTOFF    CMakeFiles/cmTryCompileExec395731180.dir/src.c.o  -o cmTryCompileExec395731180 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <time.h>

int main()
{
   static struct tm tmp;
   if (sizeof(tmp.tm_gmtoff))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4162834740/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4162834740.dir/build.make CMakeFiles/cmTryCompileExec4162834740.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4162834740.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC   -o CMakeFiles/cmTryCompileExec4162834740.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec4162834740
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec4162834740.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_STRUCT_STAT_ST_MTIM_TV_NSEC    CMakeFiles/cmTryCompileExec4162834740.dir/src.c.o  -o cmTryCompileExec4162834740 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_mtim.tv_nsec))
      return 0;
  return 0;
}

Performing C SOURCE FILE Test HAVE_STRUCT_STAT_ST_BLKSIZE succeded with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec336428040/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec336428040.dir/build.make CMakeFiles/cmTryCompileExec336428040.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec336428040.dir/src.c.o
/usr/bin/clang   -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE   -o CMakeFiles/cmTryCompileExec336428040.dir/src.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/src.c
Linking C executable cmTryCompileExec336428040
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec336428040.dir/link.txt --verbose=1
/usr/bin/clang    -w  -DHAVE_STRUCT_STAT_ST_BLKSIZE    CMakeFiles/cmTryCompileExec336428040.dir/src.c.o  -o cmTryCompileExec336428040 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'

Source file was:

#include <sys/types.h>
#include <sys/stat.h>

int main()
{
   static struct stat tmp;
   if (sizeof(tmp.st_blksize))
      return 0;
  return 0;
}

Determining size of short passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1979047869/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1979047869.dir/build.make CMakeFiles/cmTryCompileExec1979047869.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1979047869.dir/SIZE_OF_SHORT.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1979047869.dir/SIZE_OF_SHORT.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_SHORT.c
Linking C executable cmTryCompileExec1979047869
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1979047869.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1979047869.dir/SIZE_OF_SHORT.c.o  -o cmTryCompileExec1979047869 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec100788906/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec100788906.dir/build.make CMakeFiles/cmTryCompileExec100788906.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec100788906.dir/SIZE_OF_INT.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec100788906.dir/SIZE_OF_INT.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_INT.c
Linking C executable cmTryCompileExec100788906
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec100788906.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec100788906.dir/SIZE_OF_INT.c.o  -o cmTryCompileExec100788906 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2736522200/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2736522200.dir/build.make CMakeFiles/cmTryCompileExec2736522200.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2736522200.dir/SIZE_OF_LONG.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2736522200.dir/SIZE_OF_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_LONG.c
Linking C executable cmTryCompileExec2736522200
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2736522200.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2736522200.dir/SIZE_OF_LONG.c.o  -o cmTryCompileExec2736522200 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of long long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec997347928/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec997347928.dir/build.make CMakeFiles/cmTryCompileExec997347928.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec997347928.dir/SIZE_OF_LONG_LONG.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec997347928.dir/SIZE_OF_LONG_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_LONG_LONG.c
Linking C executable cmTryCompileExec997347928
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec997347928.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec997347928.dir/SIZE_OF_LONG_LONG.c.o  -o cmTryCompileExec997347928 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned short passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec897831883/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec897831883.dir/build.make CMakeFiles/cmTryCompileExec897831883.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec897831883.dir/SIZE_OF_UNSIGNED_SHORT.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec897831883.dir/SIZE_OF_UNSIGNED_SHORT.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec897831883
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec897831883.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec897831883.dir/SIZE_OF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec897831883 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2653797218/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2653797218.dir/build.make CMakeFiles/cmTryCompileExec2653797218.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2653797218.dir/SIZE_OF_UNSIGNED.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2653797218.dir/SIZE_OF_UNSIGNED.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED.c
Linking C executable cmTryCompileExec2653797218
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2653797218.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2653797218.dir/SIZE_OF_UNSIGNED.c.o  -o cmTryCompileExec2653797218 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2418340093/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2418340093.dir/build.make CMakeFiles/cmTryCompileExec2418340093.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2418340093.dir/SIZE_OF_UNSIGNED_LONG.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2418340093.dir/SIZE_OF_UNSIGNED_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG.c
Linking C executable cmTryCompileExec2418340093
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2418340093.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2418340093.dir/SIZE_OF_UNSIGNED_LONG.c.o  -o cmTryCompileExec2418340093 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of unsigned long long passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec372032797/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec372032797.dir/build.make CMakeFiles/cmTryCompileExec372032797.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec372032797.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec372032797.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_OF_UNSIGNED_LONG_LONG.c
Linking C executable cmTryCompileExec372032797
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec372032797.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec372032797.dir/SIZE_OF_UNSIGNED_LONG_LONG.c.o  -o cmTryCompileExec372032797 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int16_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3872726262/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3872726262.dir/build.make CMakeFiles/cmTryCompileExec3872726262.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3872726262.dir/INT16_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3872726262.dir/INT16_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT16_T.c
Linking C executable cmTryCompileExec3872726262
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3872726262.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3872726262.dir/INT16_T.c.o  -o cmTryCompileExec3872726262 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int32_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec696276927/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec696276927.dir/build.make CMakeFiles/cmTryCompileExec696276927.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec696276927.dir/INT32_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec696276927.dir/INT32_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT32_T.c
Linking C executable cmTryCompileExec696276927
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec696276927.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec696276927.dir/INT32_T.c.o  -o cmTryCompileExec696276927 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of int64_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2088776192/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2088776192.dir/build.make CMakeFiles/cmTryCompileExec2088776192.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2088776192.dir/INT64_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2088776192.dir/INT64_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/INT64_T.c
Linking C executable cmTryCompileExec2088776192
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2088776192.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2088776192.dir/INT64_T.c.o  -o cmTryCompileExec2088776192 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of intmax_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1169723804/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1169723804.dir/build.make CMakeFiles/cmTryCompileExec1169723804.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1169723804.dir/INTMAX_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1169723804.dir/INTMAX_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/INTMAX_T.c
Linking C executable cmTryCompileExec1169723804
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1169723804.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1169723804.dir/INTMAX_T.c.o  -o cmTryCompileExec1169723804 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint8_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec540418789/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec540418789.dir/build.make CMakeFiles/cmTryCompileExec540418789.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec540418789.dir/UINT8_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec540418789.dir/UINT8_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT8_T.c
Linking C executable cmTryCompileExec540418789
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec540418789.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec540418789.dir/UINT8_T.c.o  -o cmTryCompileExec540418789 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint16_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1989545569/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1989545569.dir/build.make CMakeFiles/cmTryCompileExec1989545569.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1989545569.dir/UINT16_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1989545569.dir/UINT16_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT16_T.c
Linking C executable cmTryCompileExec1989545569
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1989545569.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1989545569.dir/UINT16_T.c.o  -o cmTryCompileExec1989545569 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint32_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2514128217/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2514128217.dir/build.make CMakeFiles/cmTryCompileExec2514128217.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2514128217.dir/UINT32_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2514128217.dir/UINT32_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT32_T.c
Linking C executable cmTryCompileExec2514128217
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2514128217.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2514128217.dir/UINT32_T.c.o  -o cmTryCompileExec2514128217 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uint64_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3864011013/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3864011013.dir/build.make CMakeFiles/cmTryCompileExec3864011013.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3864011013.dir/UINT64_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3864011013.dir/UINT64_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINT64_T.c
Linking C executable cmTryCompileExec3864011013
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3864011013.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3864011013.dir/UINT64_T.c.o  -o cmTryCompileExec3864011013 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uintmax_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2472030692/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2472030692.dir/build.make CMakeFiles/cmTryCompileExec2472030692.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2472030692.dir/UINTMAX_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2472030692.dir/UINTMAX_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINTMAX_T.c
Linking C executable cmTryCompileExec2472030692
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2472030692.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2472030692.dir/UINTMAX_T.c.o  -o cmTryCompileExec2472030692 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of dev_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3154128377/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3154128377.dir/build.make CMakeFiles/cmTryCompileExec3154128377.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3154128377.dir/DEV_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3154128377.dir/DEV_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/DEV_T.c
Linking C executable cmTryCompileExec3154128377
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3154128377.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3154128377.dir/DEV_T.c.o  -o cmTryCompileExec3154128377 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of gid_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3945223926/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3945223926.dir/build.make CMakeFiles/cmTryCompileExec3945223926.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3945223926.dir/GID_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3945223926.dir/GID_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/GID_T.c
Linking C executable cmTryCompileExec3945223926
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3945223926.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3945223926.dir/GID_T.c.o  -o cmTryCompileExec3945223926 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of id_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1360133101/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1360133101.dir/build.make CMakeFiles/cmTryCompileExec1360133101.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1360133101.dir/ID_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1360133101.dir/ID_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/ID_T.c
Linking C executable cmTryCompileExec1360133101
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1360133101.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1360133101.dir/ID_T.c.o  -o cmTryCompileExec1360133101 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of mode_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1927857058/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1927857058.dir/build.make CMakeFiles/cmTryCompileExec1927857058.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1927857058.dir/MODE_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1927857058.dir/MODE_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/MODE_T.c
Linking C executable cmTryCompileExec1927857058
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1927857058.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1927857058.dir/MODE_T.c.o  -o cmTryCompileExec1927857058 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of off_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3943995773/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3943995773.dir/build.make CMakeFiles/cmTryCompileExec3943995773.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3943995773.dir/OFF_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3943995773.dir/OFF_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/OFF_T.c
Linking C executable cmTryCompileExec3943995773
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3943995773.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3943995773.dir/OFF_T.c.o  -o cmTryCompileExec3943995773 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of size_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2902436003/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2902436003.dir/build.make CMakeFiles/cmTryCompileExec2902436003.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2902436003.dir/SIZE_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2902436003.dir/SIZE_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZE_T.c
Linking C executable cmTryCompileExec2902436003
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2902436003.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2902436003.dir/SIZE_T.c.o  -o cmTryCompileExec2902436003 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of ssize_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1576143098/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1576143098.dir/build.make CMakeFiles/cmTryCompileExec1576143098.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1576143098.dir/SSIZE_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1576143098.dir/SSIZE_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SSIZE_T.c
Linking C executable cmTryCompileExec1576143098
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1576143098.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1576143098.dir/SSIZE_T.c.o  -o cmTryCompileExec1576143098 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uid_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2084366204/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2084366204.dir/build.make CMakeFiles/cmTryCompileExec2084366204.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2084366204.dir/UID_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2084366204.dir/UID_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UID_T.c
Linking C executable cmTryCompileExec2084366204
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2084366204.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2084366204.dir/UID_T.c.o  -o cmTryCompileExec2084366204 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of pid_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2141839220/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2141839220.dir/build.make CMakeFiles/cmTryCompileExec2141839220.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2141839220.dir/PID_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec2141839220.dir/PID_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/PID_T.c
Linking C executable cmTryCompileExec2141839220
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2141839220.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec2141839220.dir/PID_T.c.o  -o cmTryCompileExec2141839220 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of intptr_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1099533247/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1099533247.dir/build.make CMakeFiles/cmTryCompileExec1099533247.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1099533247.dir/INTPTR_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec1099533247.dir/INTPTR_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/INTPTR_T.c
Linking C executable cmTryCompileExec1099533247
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec1099533247.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec1099533247.dir/INTPTR_T.c.o  -o cmTryCompileExec1099533247 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of uintptr_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3575452672/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3575452672.dir/build.make CMakeFiles/cmTryCompileExec3575452672.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3575452672.dir/UINTPTR_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3575452672.dir/UINTPTR_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/UINTPTR_T.c
Linking C executable cmTryCompileExec3575452672
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3575452672.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3575452672.dir/UINTPTR_T.c.o  -o cmTryCompileExec3575452672 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining size of wchar_t passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3067880215/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3067880215.dir/build.make CMakeFiles/cmTryCompileExec3067880215.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3067880215.dir/SIZEOF_WCHAR_T.c.o
/usr/bin/clang   -w     -o CMakeFiles/cmTryCompileExec3067880215.dir/SIZEOF_WCHAR_T.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/SIZEOF_WCHAR_T.c
Linking C executable cmTryCompileExec3067880215
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3067880215.dir/link.txt --verbose=1
/usr/bin/clang    -w      CMakeFiles/cmTryCompileExec3067880215.dir/SIZEOF_WCHAR_T.c.o  -o cmTryCompileExec3067880215 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Checking support for ARCHIVE_CRYPTO_MD5_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3074375366/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3074375366.dir/build.make CMakeFiles/cmTryCompileExec3074375366.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3074375366.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3074375366.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:61:10: fatal error: 'md5.h' file not found
#include <md5.h>
         ^
1 error generated.
make[5]: *** [CMakeFiles/cmTryCompileExec3074375366.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3074375366/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2191681954/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2191681954.dir/build.make CMakeFiles/cmTryCompileExec2191681954.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2191681954.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2191681954.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:64:10: fatal error: 'rmd160.h' file not found
#include <rmd160.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2191681954.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2191681954/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1785374667/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1785374667.dir/build.make CMakeFiles/cmTryCompileExec1785374667.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1785374667.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1785374667.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:67:10: fatal error: 'sha1.h' file not found
#include <sha1.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1785374667.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1785374667/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1512153518/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1512153518.dir/build.make CMakeFiles/cmTryCompileExec1512153518.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1512153518.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1512153518.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1512153518.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1512153518/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2565331959/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2565331959.dir/build.make CMakeFiles/cmTryCompileExec2565331959.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2565331959.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2565331959.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2565331959.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2565331959/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3805403446/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3805403446.dir/build.make CMakeFiles/cmTryCompileExec3805403446.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3805403446.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3805403446.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3805403446.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3805403446/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC2 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1051155620/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1051155620.dir/build.make CMakeFiles/cmTryCompileExec1051155620.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1051155620.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1051155620.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1051155620.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1051155620/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC2 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3027876134/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3027876134.dir/build.make CMakeFiles/cmTryCompileExec3027876134.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3027876134.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3027876134.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3027876134.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3027876134/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC2 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2306535982/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2306535982.dir/build.make CMakeFiles/cmTryCompileExec2306535982.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2306535982.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2306535982.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2306535982.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2306535982/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC2
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBC3 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1543984939/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1543984939.dir/build.make CMakeFiles/cmTryCompileExec1543984939.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1543984939.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1543984939.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1543984939.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1543984939/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBC3 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2341280028/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2341280028.dir/build.make CMakeFiles/cmTryCompileExec2341280028.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2341280028.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec2341280028.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec2341280028.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec2341280028/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBC3 failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3897506600/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3897506600.dir/build.make CMakeFiles/cmTryCompileExec3897506600.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3897506600.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3897506600.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:78:10: fatal error: 'sha2.h' file not found
#include <sha2.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3897506600.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3897506600/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBC3
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBSYSTEM failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1068389007/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1068389007.dir/build.make CMakeFiles/cmTryCompileExec1068389007.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1068389007.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1068389007.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:10: fatal error: 'CommonCrypto/CommonDigest.h' file not found
#include <CommonCrypto/CommonDigest.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1068389007.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1068389007/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBSYSTEM failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1032968953/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1032968953.dir/build.make CMakeFiles/cmTryCompileExec1032968953.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1032968953.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1032968953.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:10: fatal error: 'CommonCrypto/CommonDigest.h' file not found
#include <CommonCrypto/CommonDigest.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1032968953.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1032968953/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBSYSTEM failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec315464778/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec315464778.dir/build.make CMakeFiles/cmTryCompileExec315464778.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec315464778.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec315464778.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:10: fatal error: 'CommonCrypto/CommonDigest.h' file not found
#include <CommonCrypto/CommonDigest.h>
         ^
1 error generated.
make[5]: *** [CMakeFiles/cmTryCompileExec315464778.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec315464778/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA384_LIBSYSTEM failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1450887098/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1450887098.dir/build.make CMakeFiles/cmTryCompileExec1450887098.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1450887098.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1450887098.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:10: fatal error: 'CommonCrypto/CommonDigest.h' file not found
#include <CommonCrypto/CommonDigest.h>
         ^
1 error generated.
make[5]: *** [CMakeFiles/cmTryCompileExec1450887098.dir/check_crypto_md.c.o] Error 1
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1450887098/fast] Error 2

Source file was:

#define ARCHIVE_SHA384_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA384_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBSYSTEM failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec1981423287/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec1981423287.dir/build.make CMakeFiles/cmTryCompileExec1981423287.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec1981423287.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec1981423287.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:112:10: fatal error: 'CommonCrypto/CommonDigest.h' file not found
#include <CommonCrypto/CommonDigest.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec1981423287.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec1981423287/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBSYSTEM
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_MD5_LIBMD failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec4108001326/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec4108001326.dir/build.make CMakeFiles/cmTryCompileExec4108001326.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec4108001326.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec4108001326.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:91:10: fatal error: 'md5.h' file not found
#include <md5.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec4108001326.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec4108001326/fast] Error 2

Source file was:

#define ARCHIVE_MD5_COMPILE_TEST
#define ARCHIVE_CRYPTO_MD5_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_RMD160_LIBMD failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3983752714/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3983752714.dir/build.make CMakeFiles/cmTryCompileExec3983752714.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3983752714.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3983752714.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:94:10: fatal error: 'ripemd.h' file not found
#include <ripemd.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3983752714.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3983752714/fast] Error 2

Source file was:

#define ARCHIVE_RMD160_COMPILE_TEST
#define ARCHIVE_CRYPTO_RMD160_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA1_LIBMD failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3891360697/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3891360697.dir/build.make CMakeFiles/cmTryCompileExec3891360697.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3891360697.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3891360697.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:97:10: fatal error: 'sha.h' file not found
#include <sha.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3891360697.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3891360697/fast] Error 2

Source file was:

#define ARCHIVE_SHA1_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA1_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA256_LIBMD failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec875174748/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec875174748.dir/build.make CMakeFiles/cmTryCompileExec875174748.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec875174748.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec875174748.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:100:10: fatal error: 'sha256.h' file not found
#include <sha256.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec875174748.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec875174748/fast] Error 2

Source file was:

#define ARCHIVE_SHA256_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA256_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Checking support for ARCHIVE_CRYPTO_SHA512_LIBMD failed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3526947227/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3526947227.dir/build.make CMakeFiles/cmTryCompileExec3526947227.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3526947227.dir/check_crypto_md.c.o
/usr/bin/clang   -w   -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive -I/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp    -o CMakeFiles/cmTryCompileExec3526947227.dir/check_crypto_md.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c
In file included from /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/check_crypto_md.c:36:
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Utilities/cmlibarchive/libarchive/archive_crypto_private.h:103:10: fatal error: 'sha512.h' file not found
#include <sha512.h>
         ^
1 error generated.
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[5]: *** [CMakeFiles/cmTryCompileExec3526947227.dir/check_crypto_md.c.o] Error 1
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: *** [cmTryCompileExec3526947227/fast] Error 2

Source file was:

#define ARCHIVE_SHA512_COMPILE_TEST
#define ARCHIVE_CRYPTO_SHA512_LIBMD
#define PLATFORM_CONFIG_H "check_crypto_md.h"

/*-
* Copyright (c) 2003-2007 Tim Kientzle
* Copyright (c) 2011 Andres Mejia
* Copyright (c) 2011 Michihiro NAKAJIMA
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "archive_platform.h"

#include "archive.h"
#include "archive_crypto_private.h"

/* In particular, force the configure probe to break if it tries
 * to test a combination of OpenSSL and libmd. */
#if defined(ARCHIVE_CRYPTO_OPENSSL) && defined(ARCHIVE_CRYPTO_LIBMD)
#error Cannot use both OpenSSL and libmd.
#endif

/*
 * Message digest functions for Windows platform.
 */
#if defined(ARCHIVE_CRYPTO_MD5_WIN)    ||\
	defined(ARCHIVE_CRYPTO_SHA1_WIN)   ||\
	defined(ARCHIVE_CRYPTO_SHA256_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA384_WIN) ||\
	defined(ARCHIVE_CRYPTO_SHA512_WIN)

/*
 * Initialize a Message digest.
 */
static int
win_crypto_init(Digest_CTX *ctx, ALG_ID algId)
{

	ctx->valid = 0;
	if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
	    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
		if (GetLastError() != (DWORD)NTE_BAD_KEYSET)
			return (ARCHIVE_FAILED);
		if (!CryptAcquireContext(&ctx->cryptProv, NULL, NULL,
		    PROV_RSA_FULL, CRYPT_NEWKEYSET))
			return (ARCHIVE_FAILED);
	}

	if (!CryptCreateHash(ctx->cryptProv, algId, 0, 0, &ctx->hash)) {
		CryptReleaseContext(ctx->cryptProv, 0);
		return (ARCHIVE_FAILED);
	}

	ctx->valid = 1;
	return (ARCHIVE_OK);
}

/*
 * Update a Message digest.
 */
static int
win_crypto_Update(Digest_CTX *ctx, const unsigned char *buf, size_t len)
{

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptHashData(ctx->hash,
		      (unsigned char *)(uintptr_t)buf,
		      (DWORD)len, 0);
	return (ARCHIVE_OK);
}

static int
win_crypto_Final(unsigned char *buf, size_t bufsize, Digest_CTX *ctx)
{
	DWORD siglen = bufsize;

	if (!ctx->valid)
		return (ARCHIVE_FAILED);

	CryptGetHashParam(ctx->hash, HP_HASHVAL, buf, &siglen, 0);
	CryptDestroyHash(ctx->hash);
	CryptReleaseContext(ctx->cryptProv, 0);
	ctx->valid = 0;
	return (ARCHIVE_OK);
}

#endif /* defined(ARCHIVE_CRYPTO_*_WIN) */


/* MD5 implementations */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)

static int
__archive_libc_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)

static int
__archive_libmd_md5init(archive_md5_ctx *ctx)
{
  MD5Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  MD5Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_md5final(archive_md5_ctx *ctx, void *md)
{
  MD5Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)

static int
__archive_libsystem_md5init(archive_md5_ctx *ctx)
{
  CC_MD5_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_MD5_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_md5final(archive_md5_ctx *ctx, void *md)
{
  CC_MD5_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)

static int
__archive_nettle_md5init(archive_md5_ctx *ctx)
{
  md5_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  md5_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_md5final(archive_md5_ctx *ctx, void *md)
{
  md5_digest(ctx, MD5_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)

static int
__archive_openssl_md5init(archive_md5_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_md5());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_md5final(archive_md5_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_MD5_WIN)

static int
__archive_windowsapi_md5init(archive_md5_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_MD5));
}

static int
__archive_windowsapi_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_md5final(archive_md5_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 16, ctx));
}

#else

static int
__archive_stub_md5init(archive_md5_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5update(archive_md5_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_md5final(archive_md5_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* RIPEMD160 implementations */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)

static int
__archive_libc_ripemd160init(archive_rmd160_ctx *ctx)
{
  RMD160Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RMD160Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RMD160Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)

static int
__archive_libmd_ripemd160init(archive_rmd160_ctx *ctx)
{
  RIPEMD160_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  RIPEMD160_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  RIPEMD160_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)

static int
__archive_nettle_ripemd160init(archive_rmd160_ctx *ctx)
{
  ripemd160_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  ripemd160_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  ripemd160_digest(ctx, RIPEMD160_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)

static int
__archive_openssl_ripemd160init(archive_rmd160_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_ripemd160());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#else

static int
__archive_stub_ripemd160init(archive_rmd160_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160update(archive_rmd160_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_ripemd160final(archive_rmd160_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA1 implementations */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)

static int
__archive_libc_sha1init(archive_sha1_ctx *ctx)
{
  SHA1Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)

static int
__archive_libmd_sha1init(archive_sha1_ctx *ctx)
{
  SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha1final(archive_sha1_ctx *ctx, void *md)
{
  SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)

static int
__archive_libsystem_sha1init(archive_sha1_ctx *ctx)
{
  CC_SHA1_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA1_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha1final(archive_sha1_ctx *ctx, void *md)
{
  CC_SHA1_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)

static int
__archive_nettle_sha1init(archive_sha1_ctx *ctx)
{
  sha1_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  sha1_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha1final(archive_sha1_ctx *ctx, void *md)
{
  sha1_digest(ctx, SHA1_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)

static int
__archive_openssl_sha1init(archive_sha1_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha1());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha1final(archive_sha1_ctx *ctx, void *md)
{
  /* HACK: archive_write_set_format_xar.c is finalizing empty contexts, so
   * this is meant to cope with that. Real fix is probably to fix
   * archive_write_set_format_xar.c
   */
  if (ctx->digest)
    EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)

static int
__archive_windowsapi_sha1init(archive_sha1_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA1));
}

static int
__archive_windowsapi_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha1final(archive_sha1_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 20, ctx));
}

#else

static int
__archive_stub_sha1init(archive_sha1_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1update(archive_sha1_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha1final(archive_sha1_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA256 implementations */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)

static int
__archive_libc_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)

static int
__archive_libc2_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)

static int
__archive_libc3_sha256init(archive_sha256_ctx *ctx)
{
  SHA256Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)

static int
__archive_libmd_sha256init(archive_sha256_ctx *ctx)
{
  SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha256final(archive_sha256_ctx *ctx, void *md)
{
  SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)

static int
__archive_libsystem_sha256init(archive_sha256_ctx *ctx)
{
  CC_SHA256_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA256_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha256final(archive_sha256_ctx *ctx, void *md)
{
  CC_SHA256_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)

static int
__archive_nettle_sha256init(archive_sha256_ctx *ctx)
{
  sha256_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  sha256_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha256final(archive_sha256_ctx *ctx, void *md)
{
  sha256_digest(ctx, SHA256_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)

static int
__archive_openssl_sha256init(archive_sha256_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha256());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha256final(archive_sha256_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)

static int
__archive_windowsapi_sha256init(archive_sha256_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_256));
}

static int
__archive_windowsapi_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha256final(archive_sha256_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 32, ctx));
}

#else

static int
__archive_stub_sha256init(archive_sha256_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256update(archive_sha256_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha256final(archive_sha256_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA384 implementations */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)

static int
__archive_libc_sha384init(archive_sha384_ctx *ctx)
{
  SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)

static int
__archive_libc2_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)

static int
__archive_libc3_sha384init(archive_sha384_ctx *ctx)
{
  SHA384Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA384Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha384final(archive_sha384_ctx *ctx, void *md)
{
  SHA384Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)

static int
__archive_libsystem_sha384init(archive_sha384_ctx *ctx)
{
  CC_SHA384_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA384_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha384final(archive_sha384_ctx *ctx, void *md)
{
  CC_SHA384_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)

static int
__archive_nettle_sha384init(archive_sha384_ctx *ctx)
{
  sha384_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  sha384_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha384final(archive_sha384_ctx *ctx, void *md)
{
  sha384_digest(ctx, SHA384_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)

static int
__archive_openssl_sha384init(archive_sha384_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha384());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha384final(archive_sha384_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)

static int
__archive_windowsapi_sha384init(archive_sha384_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_384));
}

static int
__archive_windowsapi_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha384final(archive_sha384_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 48, ctx));
}

#else

static int
__archive_stub_sha384init(archive_sha384_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384update(archive_sha384_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha384final(archive_sha384_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* SHA512 implementations */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)

static int
__archive_libc_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)

static int
__archive_libc2_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc2_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)

static int
__archive_libc3_sha512init(archive_sha512_ctx *ctx)
{
  SHA512Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libc3_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)

static int
__archive_libmd_sha512init(archive_sha512_ctx *ctx)
{
  SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libmd_sha512final(archive_sha512_ctx *ctx, void *md)
{
  SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)

static int
__archive_libsystem_sha512init(archive_sha512_ctx *ctx)
{
  CC_SHA512_Init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  CC_SHA512_Update(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_libsystem_sha512final(archive_sha512_ctx *ctx, void *md)
{
  CC_SHA512_Final(md, ctx);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)

static int
__archive_nettle_sha512init(archive_sha512_ctx *ctx)
{
  sha512_init(ctx);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  sha512_update(ctx, insize, indata);
  return (ARCHIVE_OK);
}

static int
__archive_nettle_sha512final(archive_sha512_ctx *ctx, void *md)
{
  sha512_digest(ctx, SHA512_DIGEST_SIZE, md);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)

static int
__archive_openssl_sha512init(archive_sha512_ctx *ctx)
{
  EVP_DigestInit(ctx, EVP_sha512());
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  EVP_DigestUpdate(ctx, indata, insize);
  return (ARCHIVE_OK);
}

static int
__archive_openssl_sha512final(archive_sha512_ctx *ctx, void *md)
{
  EVP_DigestFinal(ctx, md, NULL);
  return (ARCHIVE_OK);
}

#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)

static int
__archive_windowsapi_sha512init(archive_sha512_ctx *ctx)
{
  return (win_crypto_init(ctx, CALG_SHA_512));
}

static int
__archive_windowsapi_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
  return (win_crypto_Update(ctx, indata, insize));
}

static int
__archive_windowsapi_sha512final(archive_sha512_ctx *ctx, void *md)
{
  return (win_crypto_Final(md, 64, ctx));
}

#else

static int
__archive_stub_sha512init(archive_sha512_ctx *ctx)
{
	(void)ctx; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512update(archive_sha512_ctx *ctx, const void *indata,
    size_t insize)
{
	(void)ctx; /* UNUSED */
	(void)indata; /* UNUSED */
	(void)insize; /* UNUSED */
	return (ARCHIVE_FAILED);
}

static int
__archive_stub_sha512final(archive_sha512_ctx *ctx, void *md)
{
	(void)ctx; /* UNUSED */
	(void)md; /* UNUSED */
	return (ARCHIVE_FAILED);
}

#endif

/* NOTE: Crypto functions are set based on availability and by the following
 * order of preference.
 * 1. libc
 * 2. libc2
 * 3. libc3
 * 4. libSystem
 * 5. OpenSSL
 * 6. Windows API
 */
const struct archive_crypto __archive_crypto =
{
/* MD5 */
#if defined(ARCHIVE_CRYPTO_MD5_LIBC)
  &__archive_libc_md5init,
  &__archive_libc_md5update,
  &__archive_libc_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBMD)
  &__archive_libmd_md5init,
  &__archive_libmd_md5update,
  &__archive_libmd_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_LIBSYSTEM)
  &__archive_libsystem_md5init,
  &__archive_libsystem_md5update,
  &__archive_libsystem_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_NETTLE)
  &__archive_nettle_md5init,
  &__archive_nettle_md5update,
  &__archive_nettle_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_OPENSSL)
  &__archive_openssl_md5init,
  &__archive_openssl_md5update,
  &__archive_openssl_md5final,
#elif defined(ARCHIVE_CRYPTO_MD5_WIN)
  &__archive_windowsapi_md5init,
  &__archive_windowsapi_md5update,
  &__archive_windowsapi_md5final,
#elif !defined(ARCHIVE_MD5_COMPILE_TEST)
  &__archive_stub_md5init,
  &__archive_stub_md5update,
  &__archive_stub_md5final,
#endif

/* RIPEMD160 */
#if defined(ARCHIVE_CRYPTO_RMD160_LIBC)
  &__archive_libc_ripemd160init,
  &__archive_libc_ripemd160update,
  &__archive_libc_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_LIBMD)
  &__archive_libmd_ripemd160init,
  &__archive_libmd_ripemd160update,
  &__archive_libmd_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_NETTLE)
  &__archive_nettle_ripemd160init,
  &__archive_nettle_ripemd160update,
  &__archive_nettle_ripemd160final,
#elif defined(ARCHIVE_CRYPTO_RMD160_OPENSSL)
  &__archive_openssl_ripemd160init,
  &__archive_openssl_ripemd160update,
  &__archive_openssl_ripemd160final,
#elif !defined(ARCHIVE_RMD160_COMPILE_TEST)
  &__archive_stub_ripemd160init,
  &__archive_stub_ripemd160update,
  &__archive_stub_ripemd160final,
#endif

/* SHA1 */
#if defined(ARCHIVE_CRYPTO_SHA1_LIBC)
  &__archive_libc_sha1init,
  &__archive_libc_sha1update,
  &__archive_libc_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBMD)
  &__archive_libmd_sha1init,
  &__archive_libmd_sha1update,
  &__archive_libmd_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_LIBSYSTEM)
  &__archive_libsystem_sha1init,
  &__archive_libsystem_sha1update,
  &__archive_libsystem_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_NETTLE)
  &__archive_nettle_sha1init,
  &__archive_nettle_sha1update,
  &__archive_nettle_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_OPENSSL)
  &__archive_openssl_sha1init,
  &__archive_openssl_sha1update,
  &__archive_openssl_sha1final,
#elif defined(ARCHIVE_CRYPTO_SHA1_WIN)
  &__archive_windowsapi_sha1init,
  &__archive_windowsapi_sha1update,
  &__archive_windowsapi_sha1final,
#elif !defined(ARCHIVE_SHA1_COMPILE_TEST)
  &__archive_stub_sha1init,
  &__archive_stub_sha1update,
  &__archive_stub_sha1final,
#endif

/* SHA256 */
#if defined(ARCHIVE_CRYPTO_SHA256_LIBC)
  &__archive_libc_sha256init,
  &__archive_libc_sha256update,
  &__archive_libc_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC2)
  &__archive_libc2_sha256init,
  &__archive_libc2_sha256update,
  &__archive_libc2_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBC3)
  &__archive_libc3_sha256init,
  &__archive_libc3_sha256update,
  &__archive_libc3_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBMD)
  &__archive_libmd_sha256init,
  &__archive_libmd_sha256update,
  &__archive_libmd_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_LIBSYSTEM)
  &__archive_libsystem_sha256init,
  &__archive_libsystem_sha256update,
  &__archive_libsystem_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_NETTLE)
  &__archive_nettle_sha256init,
  &__archive_nettle_sha256update,
  &__archive_nettle_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_OPENSSL)
  &__archive_openssl_sha256init,
  &__archive_openssl_sha256update,
  &__archive_openssl_sha256final,
#elif defined(ARCHIVE_CRYPTO_SHA256_WIN)
  &__archive_windowsapi_sha256init,
  &__archive_windowsapi_sha256update,
  &__archive_windowsapi_sha256final,
#elif !defined(ARCHIVE_SHA256_COMPILE_TEST)
  &__archive_stub_sha256init,
  &__archive_stub_sha256update,
  &__archive_stub_sha256final,
#endif

/* SHA384 */
#if defined(ARCHIVE_CRYPTO_SHA384_LIBC)
  &__archive_libc_sha384init,
  &__archive_libc_sha384update,
  &__archive_libc_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC2)
  &__archive_libc2_sha384init,
  &__archive_libc2_sha384update,
  &__archive_libc2_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBC3)
  &__archive_libc3_sha384init,
  &__archive_libc3_sha384update,
  &__archive_libc3_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_LIBSYSTEM)
  &__archive_libsystem_sha384init,
  &__archive_libsystem_sha384update,
  &__archive_libsystem_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_NETTLE)
  &__archive_nettle_sha384init,
  &__archive_nettle_sha384update,
  &__archive_nettle_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_OPENSSL)
  &__archive_openssl_sha384init,
  &__archive_openssl_sha384update,
  &__archive_openssl_sha384final,
#elif defined(ARCHIVE_CRYPTO_SHA384_WIN)
  &__archive_windowsapi_sha384init,
  &__archive_windowsapi_sha384update,
  &__archive_windowsapi_sha384final,
#elif !defined(ARCHIVE_SHA384_COMPILE_TEST)
  &__archive_stub_sha384init,
  &__archive_stub_sha384update,
  &__archive_stub_sha384final,
#endif

/* SHA512 */
#if defined(ARCHIVE_CRYPTO_SHA512_LIBC)
  &__archive_libc_sha512init,
  &__archive_libc_sha512update,
  &__archive_libc_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC2)
  &__archive_libc2_sha512init,
  &__archive_libc2_sha512update,
  &__archive_libc2_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBC3)
  &__archive_libc3_sha512init,
  &__archive_libc3_sha512update,
  &__archive_libc3_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBMD)
  &__archive_libmd_sha512init,
  &__archive_libmd_sha512update,
  &__archive_libmd_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_LIBSYSTEM)
  &__archive_libsystem_sha512init,
  &__archive_libsystem_sha512update,
  &__archive_libsystem_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_NETTLE)
  &__archive_nettle_sha512init,
  &__archive_nettle_sha512update,
  &__archive_nettle_sha512final,
#elif defined(ARCHIVE_CRYPTO_SHA512_OPENSSL)
  &__archive_openssl_sha512init,
  &__archive_openssl_sha512update,
  &__archive_openssl_sha512final
#elif defined(ARCHIVE_CRYPTO_SHA512_WIN)
  &__archive_windowsapi_sha512init,
  &__archive_windowsapi_sha512update,
  &__archive_windowsapi_sha512final
#elif !defined(ARCHIVE_SHA512_COMPILE_TEST)
  &__archive_stub_sha512init,
  &__archive_stub_sha512update,
  &__archive_stub_sha512final
#endif
};


int
main(int argc, char **argv)
{
  archive__ctx ctx;
  archive__init(&ctx);
  archive__update(&ctx, *argv, argc);
  archive__final(&ctx, NULL);
  return 0;
}

Determining size of unsigned short passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3859500820/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3859500820.dir/build.make CMakeFiles/cmTryCompileExec3859500820.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3859500820.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3859500820.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CheckTypeSize/CMAKE_SIZEOF_UNSIGNED_SHORT.c
Linking C executable cmTryCompileExec3859500820
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3859500820.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3859500820.dir/CMAKE_SIZEOF_UNSIGNED_SHORT.c.o  -o cmTryCompileExec3859500820 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the function wsyncup exists in the /usr/lib/x86_64-linux-gnu/libcurses.so passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec2759557556/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec2759557556.dir/build.make CMakeFiles/cmTryCompileExec2759557556.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec2759557556.dir/CheckFunctionExists.c.o
/usr/bin/clang   -DCHECK_FUNCTION_EXISTS=wsyncup   -o CMakeFiles/cmTryCompileExec2759557556.dir/CheckFunctionExists.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Modules/CheckFunctionExists.c
Linking C executable cmTryCompileExec2759557556
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec2759557556.dir/link.txt --verbose=1
/usr/bin/clang     -DCHECK_FUNCTION_EXISTS=wsyncup    CMakeFiles/cmTryCompileExec2759557556.dir/CheckFunctionExists.c.o  -o cmTryCompileExec2759557556 -rdynamic -lcurses 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


Determining if the include file elf.h exists passed with the following output:
Change Dir: /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp

Run Build Command:/usr/bin/make "cmTryCompileExec3646071649/fast"
make[4]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make -f CMakeFiles/cmTryCompileExec3646071649.dir/build.make CMakeFiles/cmTryCompileExec3646071649.dir/build
make[5]: Entering directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_progress_report /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CMakeFiles 1
Building C object CMakeFiles/cmTryCompileExec3646071649.dir/CheckIncludeFile.c.o
/usr/bin/clang    -o CMakeFiles/cmTryCompileExec3646071649.dir/CheckIncludeFile.c.o   -c /home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp/CheckIncludeFile.c
Linking C executable cmTryCompileExec3646071649
/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/Bootstrap.cmk/cmake -E cmake_link_script CMakeFiles/cmTryCompileExec3646071649.dir/link.txt --verbose=1
/usr/bin/clang         CMakeFiles/cmTryCompileExec3646071649.dir/CheckIncludeFile.c.o  -o cmTryCompileExec3646071649 -rdynamic 
make[5]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'
make[4]: Leaving directory `/home/projects/R7800-V1.0.0.40_gpl_src/build_dir/host/cmake-2.8.9/CMakeFiles/CMakeTmp'


